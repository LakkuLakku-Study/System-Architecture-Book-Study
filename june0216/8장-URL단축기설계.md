# 1단계 : 문제 이해 및 설계 범위 확정

- URL 단축키 동작 예제
    - https://www.systeminterview.com/q=chatsystem&c=loggedin&v=v3&l=long이 입력으로 주어졌을 때
    - 이 서비스는 https://tinyurl.com/y7ke-ocwj와 같은 단축 URL을 결과를 제공해야한다.
    - 이때 URL에 접속하면 원래 URL로 갈 수 있어야 한다.
- 트래픽 규모?
    - 매일 1억 개의 단축 URL을 만들어낼 수 있어야 한다.
- 단축 URL의 길이는 어느 정도?
    - 짧으면 짧을수록 좋음
- 단축 URL에 포함될 문자에 제한이 있나?
    - 단축 URL에는 숫자(0부터 9까지) 영문자(a부터 z, A부터 Z까지)만 사용 가능
- 단축된 URL을 시스템에서 지우거나 갱신할 수 있는지?
    - 시스템을 단순화하기 위해 삭제나 갱신은 할 수 없다고 가정

### 기본적인 기능

1) URL **단축**

주어진 긴 URL을 훨씬 짧게 줄인다. 

2) URL **리디렉션**

축약된 URL로 HTTP 요청이 오면 원래 URL로 안내 

3) 높은 가용성과 규모 확장성, 그리고 장내 감내가 요구된다. 

# 2단계 : 개략적 설계안 제시 및 동의 구하기

## API 엔드포인트

- 클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신
- 이 엔드포인트를 REST 스타일로 설계할 것이다.
- URL 단축기는 기본적으로 두 개의 엔드포인트를 필요로 한다.
    1. URL 단축용 엔드포인트
        - 새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 실어서 POST 요청을 보내야 한다.
        - 이 엔드포인트는 다음과 같은 형태를 띤다.
            - `POST /api/v1/data/shorten`
                - 인자: {longUrl: longURLstring}
                - 반환: 단축 URL
    2. URL 리다이렉션용 엔드포인트
        - 단축 URL에 대해서 HTTP 요청이 오면 **원래 URL**로 보내주기 위한 용도의 엔드포인트이며 다음과 같은 형태를 띤다.
        - `GET /api/v1/shortUrl`
            - 반환: HTTP 리다이렉션 목적지가 될 원래 URL
            

## URL 리디렉션

### 응답

- 다음 그림은 브라우저에 단축 URL을 입력하면 무슨 일이 생기는지 보여준다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/101c31a0-7c6d-472d-97a3-d90f1d58b14c/Untitled.png)
    
    - 단축 URL을 받은 서버는 그 **URL을 원래 URL로 바꾸어서** 301 응답의 Location 헤더에 넣어 반환한다.

### **클라이언트와 서버 사이의 통신 절차**

- 다음 그림은 **클라이언트와 서버 사이의 통신 절차**를 더 자세히 보여준다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/ace78eec-7156-48b3-8e9e-f26eac924078/Untitled.png)
    
    - 여기서 유의할 것은 301 응답과 302 응답의 차이다.
        - 둘 다 리다이렉션 응답이지만 차이가 있다.
        - 1) **301 Permenently Moved = 영구이동**
            - 이 응답은 해당 URL에 대한 HTTP의 **요청의 처리 책임**이 → **영구적으로** **Location 헤더에 반환된 URL로 이전**되었다는 응답이다.
            - 영구적으로 이전되었으므로, 브라우저는 이 응답을 캐시(Cache)한다.
                - 따라서, 이후에 동일한 URL에 대한 요청은 자동으로 캐시된 새로운 URL로 전송됩니다.
            - 따라서 추후 같은 단축 URL에 요청을 보낼 필요가 있을 때 브라우저는 캐시된 원래 URL로 요청을 보내게 된다.
        - **2) 302 Found = 일시적 이동**
            - 이 응답은 주어진 URL로의 요청이 **일시적으로** Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답이다.
            - 따라서 클라이언트의 요청은 언제나 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리다이렉션 되어야 한다.
    - 이 두 방법은 각기 다른 장단점을 갖고 있다.
        - **서버 부하를 줄이는 것**이 중요하다면
            - → 301 Permanent Moved를 사용하는 것이 좋음
            - 첫 번째 요청만 단축 URL 서버로 전송될 것이기 때문이다.
                - (한 번 301 리다이렉션을 수행하면 이후 요청은 캐시된 URL로 직접 가기 때문)
        - 하지만 **트래픽 분석이 중요**할 때는
            - → 302 Found를 쓰는 쪽이 클릭 발생률이나 발생 위치를 추적하는 데 좀 더 유리할 것이다.
                - (모든 요청이 원래 URL 서버를 거치므로 클릭 발생률이나 발생 위치를 추적할 수 있음)
    
    - URL 리다이렉션을 구현하는 가장 직관적인 방법은 **해시 테이블**을 사용하는 것이다.
        - 해시 테이블에 <단축 URL, 원래 URL>의 쌍을 저장한다면, URL 리다이렉션은 다음과 같이 구현될 수 있을 것이다.
            - 원래 URL = hashTable.get(단축 URL)
            - 301 또는 302 응답 Location 헤더에 원래 URL을 넣은 후 전송

## URL 단축

- 단축 URL이 **www.tinyurl/{hashValue}** 같은 형태라고 해 보자.
- 결국 중요한 것은 긴 URL을 이 해시 값으로 대응시킬 해시 함수 fx를 찾는 일이 될 것이다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/a8da269b-428d-4778-8f30-952e274b8edb/Untitled.png)
    
- 이 함수는 다음 요구사항을 만족해야 한다.
    - 1) 입력으로 주어지는 긴 URL이 다른 값이면 → 해시 값도 달라야 한다.
    - 2) 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 **복원**될 수 있어야 한다.

# 3단계 : 상세 설계

- 지금까지 URL을 단축하는 방법과 리디렉션 처리에 관계된 개략적 설계안을 살펴보았다.
- 데이터 모델, 해시 함수, URL 단축 및 리디렉션 구체적인 설계안을 만들어 보겠다.

## 데이터 모델

- 모든 것을 해시 테이블에 두는 것은 메모리는 유한하며 비싸기 때문에 실제 시스템에 쓰일 때 **<단축 URL, 원래 URL>  순서쌍을 관계형 데이터베이스**에 저장하는 게 더 나은 방법이다.
- 간단하게 id, shortURL, longURL의 세 개 칼럼으로 구성해볼 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/2c05a18a-55c8-4868-801f-efdfc682e002/Untitled.png)

## 해시 함수

- 해시 함수는 원래 URL을 단축 URL로 변환하는 데 쓰인다.
- 편의상 해시 함수가 계산하는 단축 URL 값을 hashValue라고 지칭

### 해시 값 길이

- hashValue는 [0-9, a-z, A-Z]의 문자들로 구성
    - 사용할 수 있는 문자의 개수는 10+26+26 = 62개
    - hashValue의 길이를 정하기 위해서는 62^n >= 3650억인 n의 최솟값을 찾아야 한다.
    - 개략적으로 계산했던 추정치에 따르면 이 시스템은 3650억 개의 URL을 만들어 낼 수 있어야 한다.
- hashValue의 길이와, 해시 함수가 만들 수 있는 URL 개수 사이의 관계를 나타내는 표
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/11a6e516-dbb8-40f0-a0ee-3d435c78a5e4/Untitled.png)
    
- n=7이면, 3.5조 개의 URL을 만들 수 있다.
    - 요구사항을 만족시키기 충분한 값임 → hashValue의 길이는 7로 가정한다.

### 해시 함수 구현 기술

- (1) **해시 후 충돌 해소**
    - 긴 URL을 줄이려면, 원래 URL을 7글자 문자열로 줄이는 해시 함수가 필요하다.
    - 손쉬운 방법은 CRC32, MD5, SHA-1 같이 잘 알려진 해시 함수를 이용하는 것이다.
    - 이들 함수를 사용하여 'https:/en.wikipedia.org/wiki/Systems_design'을 축약한 결과는 다음과 같다.
    
    !https://velog.velcdn.com/images/minu/post/5693782d-2e7c-43d0-a8f6-1568aaccd64a/image.png
    
    - 그러나, CRC32가 계산한 가장 짧은 해시값조차도 7보다는 길다. 어떻게 줄일 수 있을까?
    - 이 문제를 해결할 첫 번째 방법은 계산된 해시 값에서 처음 7개 글자만 이용하는 것이다.
    - 하지만 이렇게 하면 해시 결과가 서로 충돌할 확률이 높아진다.
    - **충돌이 실제로 발생했을 때는, 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙인다.**
    - 이 절차는 다음과 같다.
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/6bf5afe1-695c-4e8b-863a-92d7cb09680a/Untitled.png)
        
        - 이 방법을 쓰면 충돌은 해소할 수 있지만 단축 URL을 생성할 때 한 번 이상 데이터베이스 질의를 해야 하므로 오버헤드가 크다.
        - 데이터베이스 대신 블룸 필터를 사용하여 충돌을 검사하면 성능을 높일 수 있다.
            - 블룸 필터는 어떤 집합에 특정 원소가 있는지 검사할 수 있도록 하는, 확률론에 기초한 공간 효율이 좋은 기술이다.
            - about 블룸 필터
                - 블룸 필터는 공간 효율성이 높은 확률론적인 데이터 구조로, 특정 요소가 집합에 포함되어 있는지를 빠르고 효율적으로 검사할 수 있습니다.
                
                블룸 필터는 다음과 같은 특징을 가진 데이터 구조입니다:
                
                - **공간 효율성:** 블룸 필터는 매우 적은 메모리 공간을 사용하여 큰 데이터 집합을 처리할 수 있습니다.
                - **확률론적 접근:** 블룸 필터는 특정 요소가 집합에 포함되어 있는지를 확률적으로 판단합니다. 즉, "포함되지 않음"은 확실하지만, "포함됨"의 경우에는 일부 오차가 있을 수 있습니다(거짓 양성 오류).
                - **충돌 회피:** 여러 해시 함수를 사용하여 충돌 가능성을 줄입니다.
                
                ### 블룸 필터의 동작 방식
                
                1. **초기화:** 블룸 필터는 크기가 m인 비트 배열을 가지고 있으며, 모든 비트는 초기에는 0으로 설정됩니다.
                2. **해시 함수:** 블룸 필터는 k개의 독립적인 해시 함수를 사용합니다. 각 해시 함수는 입력 데이터를 비트 배열의 인덱스로 변환합니다.
                3. **요소 추가:**
                    - 요소 x를 추가할 때, k개의 해시 함수를 사용하여 x를 해시합니다.
                    - 각 해시 함수는 비트 배열의 k개의 위치를 반환하고, 해당 위치의 비트를 1로 설정합니다.
                4. **요소 검사:**
                    - 요소 y가 집합에 포함되어 있는지 확인하려면, y를 k개의 해시 함수로 해시합니다.
                    - 반환된 k개의 위치가 모두 1이면, y가 집합에 포함되어 있을 확률이 높습니다.
                    - 하나라도 0이면, y는 집합에 포함되지 않은 것으로 확실합니다.
                
                ### 예시
                
                1. **요소 추가:**
                    - 예를 들어, URL "https://example.com"을 블룸 필터에 추가한다고 가정합니다.
                    - 해시 함수 h1,h2,h3를 사용하여 URL을 해시합니다.
                    - 해시 결과가 비트 배열의 위치 3, 7, 10을 반환하면, 이 위치의 비트를 1로 설정합니다.
                2. **요소 검사:**
                    - 다른 URL "https://another-example.com"이 필터에 포함되어 있는지 확인합니다.
                    - 해시 함수로 해시 결과가 위치 3, 6, 10을 반환했을 때, 위치 6의 비트가 0이면 해당 URL은 포함되지 않은 것으로 판단합니다.
                
                ### 블룸 필터의 장점과 단점
                
                - **장점:**
                    - 메모리 효율성: 매우 적은 공간을 사용하여 큰 데이터 집합을 처리할 수 있습니다.
                    - 빠른 검사: 특정 요소가 집합에 포함되어 있는지를 빠르게 검사할 수 있습니다.
                    - 간단한 구현: 기본 구조가 단순하여 구현이 쉽습니다.
                - **단점:**
                    - 거짓 양성 오류: 포함되지 않은 요소를 포함된 것처럼 잘못 판단할 수 있습니다.
                    - 요소 삭제 불가: 블룸 필터는 요소 삭제를 지원하지 않습니다. 삭제 기능을 추가하면 메모리 효율성이 떨어질 수 있습니다.
            
- (2) **base-62 변환**
    - 진법 변환(base conversion)은 URL 단축기를 구현할 때 흔히 사용되는 접근법 중 하나다.
        - 긴 숫자를 짧은 문자열로 변환하는 데 유용
        - 따로 고유한 ID 생성기를 통해 숫자를 생성하고 이를 Base-62 변환을 통해 고유한 문자열로 변환
    - 이 기법은 수의 **표현 방식이 다른 두 시스템이 같은 수를 공유해야하는 경우**에 유용하다.
    - 62진법을 쓰는 이유는 hashValue에 사용할 수 있는 문자(character) 개수가 62개이기 때문이다.
    - base-62 변환이 어떻게 이뤄지는지 보자
        - 62진법은 수를 표현하기 위해 총 62개의 문자를 사용하는 진법이다.
            - 숫자: 0-9 (10개)
            - 소문자: a-z (26개)
            - 대문자: A-Z (26개)
        - 따라서 0은 0으로, 9는 9로, 10은 a로… 61은 Z로 대응시켜 표현하도록 할 것이다.
        - 10진수로 11157의 경우 62진법으로 구하면 2TX가 되어 단축 URL은 https://tinyurl.com/2TX가 된다.
- 두 접근법 비교
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/6f7fab92-6757-4b91-98f3-06932201b171/Untitled.png)
    
    ### 해시 후 충돌 해소 전략
    
    1. **단축 URL의 길이가 고정됨**
        - 해시 함수로 생성된 단축 URL의 길이는 항상 일정합니다. 예를 들어, SHA-1 해시 함수는 항상 40자 길이의 해시 값을 생성합니다.
    2. **유일성이 보장되는 ID 생성기가 필요하지 않음**
        - 해시 함수는 동일한 입력에 대해 항상 동일한 출력을 생성합니다. 따라서 같은 URL은 항상 같은 단축 URL을 생성합니다. 단, 충돌이 발생할 가능성이 있어 추가적인 해소 전략이 필요합니다.
    3. **충돌이 가능해서 해소 전략이 필요**
        - 해시 함수는 충돌이 발생할 가능성이 있습니다. 서로 다른 두 URL이 동일한 해시 값을 가질 수 있기 때문에 충돌을 해결하기 위한 별도의 전략이 필요합니다.
    4. **ID로부터 단축 URL을 계산하는 방식이 아니라 다음에 쓸 수 있는 URL을 알아내는 것이 불가능**
        - 해시 함수로 생성된 단축 URL은 특정 순서를 따르지 않기 때문에, 단축 URL로부터 원래 URL을 쉽게 알아낼 수 없습니다. 이는 보안 측면에서 유리합니다.
    
    ### Base-62 변환
    
    1. **단축 URL의 길이가 가변적**
        - Base-62 변환 방식에서는 ID의 크기에 따라 단축 URL의 길이가 달라집니다. ID가 커질수록 단축 URL의 길이도 길어집니다.
    2. **유일성 보장 ID 생성기가 필요**
        - Base-62 변환은 단순히 숫자를 문자로 변환하는 방식입니다. 따라서 고유한 단축 URL을 생성하기 위해서는 유일성을 보장하는 ID 생성기가 필요합니다.
    3. **ID의 유일성이 보장된 후에 적용 가능한 전략이라 충돌은 아예 불가능**
        - Base-62 변환 자체는 충돌을 방지하는 기법이 아닙니다. 유일성을 보장하는 ID 생성기를 통해 이미 충돌이 없도록 설계된 상태에서 변환을 적용합니다.
    4. **ID가 1씩 증가하는 값이라고 가정하면 다음에 쓸 수 있는 단축 URL이 무엇인지 쉽게 알아낼 수 있어서 보안상 문제가 될 소지가 있음**
        - 순차적으로 증가하는 ID를 Base-62로 변환하면 다음에 생성될 단축 URL을 예측할 수 있습니다. 이는 보안 측면에서 취약점을 노출시킬 수 있습니다.
    
    ### 결론
    
    - **해시 후 충돌 해소 전략**은 고정 길이의 단축 URL을 생성하며, 해시 함수의 특성상 유일성 보장 ID 생성기가 필요하지 않습니다. 그러나 충돌이 발생할 가능성이 있어 이를 해결하기 위한 전략이 필요합니다. 또한, 단축 URL에서 원래 URL을 추론할 수 없어 보안상 유리합니다.
    - **Base-62 변환**은 ID를 가변 길이의 단축 URL로 변환하며, 유일성을 보장하기 위해 고유한 ID 생성기가 필요합니다. 충돌은 발생하지 않지만, 순차적으로 증가하는 ID를 사용할 경우 보안상 문제가 발생할 수 있습니다.
    
    따라서, 단축 URL의 유일성과 보안을 보장하기 위해서는 각각의 방법에 맞는 전략을 선택하고 적용하는 것이 중요합니다.
    

## URL 단축기 상세 설계

- URL 단축기는 시스템의 핵심 컴포넌트이므로, 그 처리 흐름이 논리적으로는 단순해야 하고 기능적으로는 언제나 동작하는 상태로 유지되어야 한다.
- 다음 그림은 62진법 변환 기법을 이용한 처리 흐름을 순서도 형태로 정리한 그림이다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/e811ba42-c256-476c-9311-80e9594ad94b/Untitled.png)
    
1. 입력으로 긴 URL을 받는다.
2. 데이터베이스에 해당 URL이 있는지 검사한다.
3. 데이터베이스에 있다면 해당 URL에 대한 단축 URL을 만든 적이 있는 것이다. 
    - 따라서 데이터베이스에서 해당 단축 URL을 가져와서 클라이언트에게 반환한다.
4. 데이터베이스에 없는 경우에는 해당 URL은 새로 접수된 것이므로 유일한 ID를 생성한다. 
    - 이 ID는 데이터베이스의 기본 키로 사용된다.
5. 62진법 변환을 적용하여 ID를 단축 URL로 만든다.
6. ID, 단축 UR, 원래 URL로 새 데이터베이스 레코드를 만든 후 단축 URL을 클라이언트에게 전달한다.

- 예제
    - 아래의 예제를 통하여 조금 더 자세하게 알아보자.
        - 입력된 URL이 '[https://en.wikipedia.org/wiki/Systems_design'이라고](https://en.wikipedia.org/wiki/Systems_design'%EC%9D%B4%EB%9D%BC%EA%B3%A0) 하자.
        - 이 URL에 대해 ID 생성기가 반환한 ID는 2009215674938이다.
        - 이 ID를 62진수로 변환하면 zn9edcu를 얻는다.
        - 아래 표와 같은 새로운 데이터베이스 레코드를 만든다.
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/2be3c2bb-69e2-441c-8498-3081f079ce0d/Untitled.png)
            
            - ID 생성기의 주된 용도는, 단축 URL을 만들 때 사용할 ID를 만드는 것이고, 이 ID는 전역적 유일성(globally unique)이 보장되는 것이어야 한다.
            - 고도로 분산된 환경에서 이런 생성기를 만드는 것은 무척 어려운 일이다.

## URL 리디렉션 상세 설계

- URL 리다이렉션 메커니즘의 상세한 설계
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/f0fc4815-0027-494a-8ab2-fc0ed8b36c4e/Untitled.png)
    
    - 쓰기보다 읽기를 더 자주 하기 때문에 <단축 URL, 원래 URL>의 쌍을 캐시에 저장하여 성능을 높인다.
- 로드밸런서의 동작 흐름은 다음과 같이 요약할 수 있다.
    1. 사용자가 단축 URL을 클릭한다.
    2. 로드밸런서가 해당 클릭으로 발생한 요청을 웹 서버에 전달한다.
    3. 단축 URL이 이미 캐시에 있는 경우에는 원래 URL을 바로 꺼내서 클라이언트에게 전달한다.
    4. 캐시에 해당 단축 URL이 없는 경우에는 데이터베이스에서 꺼낸다. 
        - 데이터베이스에 없다면 아마 사용자가 잘못된 단축 URL을 입력한 경우일 것이다.
    5. 데이터베이스에서 꺼낸 URL을 캐시에 넣은 후 사용자에게 반환한다.

# 4단계 : 마무리

- 앞에서는 URL 단축기의 API, 데이터모델, 해시 함수, URL 단축 및 리디렉션 절차를 추가함
- 추가적으로 고려할 부분운 아래와 같다.
- 처리율 제한 장치(rate limiter)
    - 지금까지 살펴본 시스템은 엄청난 양의 URL 단축 요청이 있을 경우 무력화될 수 있다는 잠재적 보안 결함을 갖고 있다.
    - 처리율 제한 장치를 두면, IP 주소를 비롯한 필터링 규칙들(filtering rule)을 이용해 요청을 걸러낼 수 있을 것이다.
- 웹 서버의 규모 확장
    - 본 설계에 포함된 웹 계층은 무상태 계층이므로, 웹 서버를 자유롭게 증설하거나 삭제할 수 있다.
- 데이터베이스의 규모 확장
    - 데이터베이스를 다중화하거나 샤딩(sharding)하여 규모 확장성을 달성할 수 있다.
- 데이터 분석 솔루션(analytics)
    - 성공적인 비즈니스를 위해서는 데이터가 중요하다.
    - URL 단축기에 데이터 분석 솔루션을 통합해 두면 어떤 링크를 얼마나 많은 사용자가 클릭했는지, 언제 주로 클릭했는지 등 중요한 정보를 알아낼 수 있을 것이다.
- 가용성, 데이터 일관성, 안정성
    - 대규모 시스템이 성공적으로 운영되기 위해서는 반드시 갖추어야 할 속성들이다.

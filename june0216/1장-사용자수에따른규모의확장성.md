# ✔️ 단일서버

- 처음 시작 → 모든 컴포넌트(웹 앱, 데이터베이스, 캐시 등)가 한 대의 서버에서 실행되는 경우

![IMG_1600093F5B7B-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/4c181778-eb8d-42ce-b96d-acb73647a004/IMG_1600093F5B7B-1.jpeg)

# ✔️  데이터베이스

- 사용자가 늘면 서버 하나로는 충분하지 않음 → 여러 서버를 두어야한다.
    - 서버 1) 웹/모바일 트래픽 처리 용도
    - 서버 2) 데이터베이스용 서버
- 장점 = 웹 계층과 데이터 계층을 분리하면 그 각각을 독립적으로 확장해 나갈 수 있게 된다.

## 어떤 데이터베이스를 사용?

### 1) 전통적인 관계형 데이터베이스(RDBMS)

- MySQL, 오라클, PostgreSQL
- 자료를 **테이블**과 **로우**, **칼럼**으로 표현
    - SQL을 사용하여 여러 테이블을 그 관계에 따라 조인하여 합칠 수 있다.

### 2) 비관계형 데이터베이스

- CouchDB, Neo4j, HBase, Amazon DynamoDB ..
- 4가지 종류 분류
    - 2-1) 키-값 저장소
    - 2-2) 그래프 저장소
    - 2-3) 칼럼 저장소
    - 2-4) 문서 저장소
- 일반적으로 조인 연산은 지원하지 않는다.

|  | SQL 데이터베이스 | noSQL 데이터베이스 |
| --- | --- | --- |
| 중점사항 | - 데이터 일관성을 위한 트랜잭션 수행→ 과정 중 일부만 반영되면 무결성이 깨지기 때문에 모두 적용(커밋)하거나 모두 취소(롤백)함  | - 서비스 가용성과 데이터 처리 성능 향상 → 데이터 일관성 제약 일부를 완화 |
| 최적의 워크로드 (적합 업무) | 무결성 및 일관성 중시
• 데이터 무결성 및 일관성이 중요한 트랜잭션 업무
• 온라인에서 다양한 집계 및 통계를 분석하는 업무
• 복잡한 계산 및 실시간 데이터 정합성이 필요한 업무 | 성능 및 가용성 중시
• 초당 동시 처리가 중요한 업무 → 아주 낮은 응답 지연시간
• 비정형 데이터( ex 문자 텍스트, 이미지 등)
• 복잡한 계산 및 실시간 데이터 정합성이 필요한 업무
• 읽기(read)처리를 자주하지만, 데이터를 자주 변경(update)하지 않는 경우 (즉, 한번의 변경으로 수십 개의 문서를 업데이트 할 필요가 없는 경우) |
| 데이터 모델 | • 엔티티 및 엔티티 간의 관계를 정의함(참조 무결성)
• 관계는 기본 및 외래 키 제약 조건으로 정의함
• 엔티티 정의 시 중복성을 줄이도록 정규화에 의한 설계가 중요함
• 테이블, 칼럼 등 DB 요소에 대한 스키마를 엄격히 관리함 | • 서비스에 맞는 DB 선택이 중요함(키-값, 문서, 그래프 등) → 데이터는 직관적 개발과 수평 확장성에 최적화
• 반정규화에 의한 설계를 기본으로 함
• 비정형화 스키마 구조로 미리 스키마를 선언하지 않음 -> 필드의 추가 삭제가 자유로움  |
| 속성 | ACID (Atomicity, Consistency, Isolation, Durability) 
• Atomicity: 트랜잭션은 최소의 업무 단위를 완벽하게 실행하거나 혹은 전혀 실행하지 않아야 함.
• Consistency: 트랜잭션이 커밋되면 데이터가 데이터베이스 스키마를 준수해야 함
• Isolation: 실행 중인 트랜젝션의 중간에 다른 트랜젝션이 접근할 수 없음
• Durability: 예기치 못한 시스템 장애시 마지막으로 상태로 복구함. | BASE (Basically Available, Soft State, Eventually Consistent)
- Basically Available: Master 서버에 장애 발생 시에도 여러 Slave 서버로 인해 무중단 서비스가 가능함(가용성)
- Soft State: 외부의 개입이 없어도 정보가 변경될 수 있으며, 일관성(Consistency)이 유지되지 않는 경우 일관성을 위해 데이터를 자동으로 수정 가능함
- Eventually Consistent: (장애 발생시)일시적으로 일관적이지 않은 상태가 되어도 일정 시간 후 일관적인 상태가 되어야한다는 의미 |
  | 성능 | - 성능 향상을 위해서 최적화 작업이 필요함 | - 클러스터 크기, 네트워크 및 애플리케이션에 의해 성능이 결정 |
  | 인터페이스 | - SQL을 통해서만 데이터 저장 및 검색이 가능함 | - 쿼리 외 다양한 API를 통한 데이터 저장 및 검색이 가능함
- 파티션 키를 사용하면 앱에서 키-값, 열 세트 또는 일련의 앱 객체 및 속성을 포함하는 반정형 문서를 검색가능 |
  | 장점 | - 데이터 중복 배제로 데이터 이상 발생 및 용량 증가를 최소화함 | - 쿼리 프로세싱이 단순화 되어 대용량 데이터 처리 성능이 향상 |
  | 단점 | - 조인이 복잡한 경우 쿼리 프로세싱도 복잡해져 성능이 저하됨 | - 데이터 중복에 의해 데이터 일관성이 저하되고 용량이 증가함 |
  | 확장 | - 일반적으로 하드웨어의 계산 성능을 높이거나 읽기 전용 워크로드의 복제물을 추가함으로써 확장됨 | - 일반적으로 거의 무제한적인 범위에서 일관된 성능을 제공하는 처리량 제고를 위해 분산형 아키텍처를 사용해 액세스 패턴이 확장 가능함 |
  | 유형 |  | 키-값 저장소: 가장 간단한 형태의 NoSQL로, 키에 하나의 값이 매핑되는 구조입니다. Redis나 DynamoDB와 같은 키-값 저장소에서의 쿼리는 주로 키를 통해 값을 검색하는 작업으로 이루어집니다. 복잡한 쿼리나 조인을 지원하지 않기 때문에 조회는 매우 빠르지만, 데이터 간의 관계를 표현하기는 어렵습니다.

문서 지향 데이터베이스: MongoDB, CouchDB가 이 범주에 속합니다. 이들 데이터베이스는 JSON, BSON, XML과 같은 문서 형식을 사용하여 데이터를 저장합니다. 문서 지향 데이터베이스에서는 문서의 필드를 기준으로 쿼리를 실행할 수 있으며, 인덱스를 활용하여 효율적인 데이터 검색을 지원합니다. 이 유형은 특정 필드에 대한 검색, 범위 쿼리, 때때로 집계 연산(예: MongoDB의 집계 파이프라인)을 지원합니다.

컬럼 패밀리 데이터베이스: Apache Cassandra, HBase가 여기에 해당됩니다. 이들은 데이터를 컬럼의 집합으로 저장하며, 각 컬럼 패밀리는 여러 컬럼의 모음입니다. 쿼리는 주로 행의 키, 컬럼 패밀리, 컬럼을 지정하여 수행되며, 효율적인 컬럼 기반 저장으로 대용량 데이터의 분산 처리에 적합합니다. 범위 쿼리나 컬럼 기반의 검색이 가능하며, 쓰기와 읽기 성능을 최적화할 수 있습니다.

그래프 데이터베이스: Neo4j, ArangoDB 등이 포함됩니다. 이들은 엔티티(노드)와 관계(엣지)를 그래프 구조로 저장하여 관계형 쿼리를 강력하게 지원합니다. 그래프 데이터베이스에서는 노드와 엣지를 통한 깊이 우선 탐색(DFS), 너비 우선 탐색(BFS) 등 복잡한 관계를 가진 데이터에 대한 쿼리가 가능합니다. |
| 관계 연산  | 관계형 DB의 join 연산
◦ SQL의 join 연산이 들어올 때 동적으로 적용
◦ Join은 더 유연한 데이터 연결을 가능하게 합니다. Join을 사용하면 다양한 조건에 따라 동적으로 데이터를 연결할 수 있습니다. | 비관계형 DB reference
◦ 이미 연관성이 정의되어 있음
◦ 저장 시점에 이미 연결이 정의되므로 이후에 변경하기가 어렵습니다. |
- 참고

  [[NoSQL] NoSQL을 사용하는 이유: RDBMS(SQL) VS NoSQL](https://csj000714.tistory.com/620)

- 왜 이메일은 수신자, 송신자, 내용으로 구성된 정형 데이터가 아닌가?
    - **이메일과 문자 메시지**: 이들은 내용, 길이, 형식이 매우 다양합니다. 예를 들어, 이메일은 텍스트 본문, 제목, 첨부 파일, 수신자 목록 등 다양한 요소를 포함할 수 있습니다. 이런 요소들은 구조화하기 어렵습니다.
- 쿼리 프로세싱이란?
    - SQL
        - Parsing, Translation : 쿼리문을 파싱하고 관계대수 식으로 변환하는 작업
        - Optimization : 질의 최적화
        - Evaluation : 최적화된 관계대수식을 보고 작업을 수행하여 결과를 도출하는 작업
    - NoSQL
        - 모든 SQL은 말 그대로 SQL을 질의언어로 사용한다. 반면 **NoSQL은 유형마다, 제품마다 다양한 질의언어가 있을 수 있다. NoSQL의 질의언어를 UnQL(Unstructured Query Language)라고도 하는데 대부분 SQL에 비해 저수준으로, 복잡한 질의가 어렵다.**
        - NoSQL 데이터베이스들은 SQL을 사용하는 관계형 데이터베이스와 달리, 데이터베이스 별로 독자적인 쿼리 언어 또는 API를 제공합니다. 예를 들어, MongoDB는 MongoDB Query Language(MQL)을, Cassandra는 CQL(Cassandra Query Language)을 사용합니다. 이러한 특성 때문에, 사용자는 NoSQL 데이터베이스를 선택할 때 어떤 쿼리 기능이 필요한지, 그리고 해당 데이터베이스가 어떤 쿼리 기능을 제공하는지를 고려해야 합니다.

# ✔️ 수직적 규모 확장 vs 수평적 규모 확장

### 방법 1) 수직적 규모 확장( = 스케일 업)

- 서버에 고사양 자원(더 좋은 CPU, 더 많은 RAM) 을 추가하는 행위
- 단순하기 때문에 → 트래픽 양이 적을 때 수직적 확장이 더 좋은 선택
- 단점
    - 1) CPU나 메모리를 무한대로 증설할 수 없으므로 → 한계가 있음
    - 2) 자동 복구 방안이나 다중화 방안을 제시하지 않는다. → 장애 발생하면 웹사이트 완전히 중단
        - → 대규모 애플리케이션을 지원한다면 수평적 규모 확장이 더 적합함

### 방법 2) 수평적 규모 확장( = 스케일 아웃)

- 더 많은 서버를 추가하는 방법

## 로드밸런서

- 여러 서버나 컴퓨터 자원에 작업을 고르게 분산하는 기술
- 스케일 아웃을 하게 되면 서버가 여러 대가 되기 때문에 각 서버에 걸리는 부하를 고르게 나누기 위해서는 로드밸런싱이 필수적으로 동반되어야 한다.
- 클라이언트의 접속을 직접 처리하지 않는다.
- 특징
    - 서버 1이 다운되면 모든 트래피은 서버 2로 전송된다. → 웹 사이트 전체가 다운되는 일이 방지된다.

### 로드밸런서 알고리즘

[정적 로드 밸런싱]

1) 라운드 로빈

클라이언트의 요청을 여러 대의 서버에 순차적으로 분배하는 방식

2) 가중치 기반 라운드 로빈

각각의 서버마다 가중치(Weight)를 매기고 가중치가 높은 서버에 클라이언트의 요청을 먼저 배분합니다. 여러 서버가 같은 사양이 아니고, 특정 서버의 스펙이 더 좋은 경우 해당 서버의 가중치를 높게 매겨 트래픽 처리량을 늘릴 수 있습니다.

3) IP 해시 방식

클라이언트 IP 주소를 해싱함 → 개별 서버에 매핑한다.

사용자 IP를 해싱하여 부하를 분산하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장합니다.

[동적 로드 밸런싱]

1) 최소 연결 방법

최소 연결 방법에서 로드 밸런서는 활성 연결이 가장 적은 서버를 확인하고 해당 서버로 트래픽을 전송합니다. 이 방법에서는 모든 연결에 모든 서버에 대해 동일한 처리 능력이 필요하다고 가정합니다.

2) 최소 응답 시간 방법

서버의 현재 연결 상태와 응답 시간을 모두 고려하여, 가장 짧은 응답 시간을 보내는 서버로 트래픽을 할당합니다. 각 서버의 가용 가능한 리소스와 성능, 처리 중인 데이터양 등이 상이할 경우 적합합니다. 조건에 잘 들어맞는 서버가 있을 시 여유 있는 서버보다 먼저 할당됩니다. 로드 밸런서는 이 알고리즘을 사용하여 모든 사용자에게 더 빠른 서비스를 보장합니다.

### 로드밸런서 유형

- **기준 : OSI 7 Layer를 기준으로 부하를 어떻게 분산할지**
- 상위 계층은 하위 계층의 데이터를 모두 가지기 때문에, 상위 계층일수록 섬세한 로드 밸런싱이 가능하고 하위 계층일수록 간단한 로드 밸런싱만 가능
- **로드 밸런서의 종류로는 L2, L3, L4, L7가 있고, 로드 밸런싱에는 L4 로드 밸런서와 L7 로드 밸런서가 가장 많이 사용**
    - **1) L4 로드 밸런서부터 포트 번호를 바탕으로 로드(부하)를 분산하는 것이 가능**
        - L4 로드 밸런서는 4 Layer 이하의 모든 계층의 정보를 가지기 때문에 **IP 주소와 포트 번호** 등을 로드 밸런싱에 활용
    - **2) L7 로드 밸런서는 HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽을 분산**
        - 패킷의 내용을 확인해서 그 내용에 따라 트래픽을 특정 서버에 전송하는 것이 가능
        - 클라이언트의 요청을 세분화하여 서버에 전달할 수 있다. → URL에 따라 부하를 분산시키거나, HTTP 헤더의 쿠키값에 따라 부하를 분산
        - **L7 로드밸런서는 서버의 응답까지도 알고 분석할 수 있다. 서버들로부터 필요한 정보를 응답 받아 클라의 요청을 전달하기 전에 서버의 상태를 파악한 후 로드밸런싱을 진행**

### 처리 과정

- L4기준으로
- 사용자는 로드밸런서의 공개 IP 주소로 접속한다. → 웹 서버는 클라이언트의 접속을 직접 처리하지 않음
- 서버끼리는 사설 IP주소( private IP address) 사용
    - 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 주소임 → 인터넷을 통해서는 접속할 수 없음
- 참고
    - 예시가 잘 되어 있음

      [Nginx로 로드밸런싱 환경을 구축해 트래픽 분산시키기](https://haon.blog/infra/nginx/load-balancing/)


## 데이터베이스 다중화

- 여러 대의 서버와 로드 밸런서를 통해 대용량 트래픽 혹은 장애 발생시 가용성을 보장하게 된다. 하지만 데이터 계층에서 DB 서버가 1개이면 장애의 자동 복구나 다중화를 지원하는 구성은 아니다. → “데이터 다중화 필요”
- **master (주 데이터베이스)** - **slave(부 데이터베이스)** 구조
    - **쓰기 연산**은 마스터에서만 지원
        - 마스터에서만 insert, delete, update 등 지원
    - 부 데이터베이스는 마스터로부터 사본을 전달받아 **읽기 연산만 지원**함
        - 보통 읽기 연산이 훨씬 많기 때문에 부 데이터베이스의 수가 더 많다.
- 장점
    - 1) 더 나은 성능 → 읽기 연산은 트래픽 분산 처리 가능 (즉, 병렬 질의 처리 가능)
    - 2) 안정성 → 여러 대에 있기 때문에 없어져도 데이터 보존 가능
    - 3) 가용성 → 장애가 나도 다른 서버에 있는 데이터를 가져와 계속 서비스 가능
- 서버 하나가 다운된다면?
    - **부 서버**가 1대인데 다운된 경우
        - → 일시적으로 읽기 연산은 주 서버가 대신 할 것이다.
    - **부 서버**가 여러 대인데 다운된 경우
        - → 다른 부 서버가 읽기 연산을 하고 추후 새로운 데이터베이스 서버가 부 서버로 추가될 것이다.
    - **마스터 데이터베이스 서버**가 다운된 경우
        - 부 서버 중 하나가 새로운 주 서버가 될 것이다. 그리고 새로운 부 서버가 추가될 것이다/
        - 부서버에 보관된 데이터가 최신이 아닐 수 있기 때문에 없는 데이터는 “복구 스크립트”를 돌려서 추가함
            - 다중 마스터
                - 다중 마스터 데이터베이스는 여러 마스터 노드를 사용하여 데이터를 관리하는 데이터베이스 아키텍처
                - 각 마스터 노드에서 동시에 발생하는 쓰기 작업을 어떻게 일관성 있게 관리할지가 중요한 문제 → 타임스탬프 방법 사용함 (가장 높은 타임스탬프를 가진 업데이트가 선택)
            - 원형 다중화
                - 고정된 크기의 버퍼를 사용하여 데이터를 순환식으로 저장하고 관리하는 방법
                - 버퍼의 시작과 끝이 연결되어 있으며, 데이터는 이 원형 구조 안에서 순환하게 됩니다. 버퍼는 일반적으로 배열로 구현되며, 두 개의 포인터—하나는 데이터 쓰기 위치를 가리키고, 다른 하나는 읽기 위치를 가리킵니다.

# ✔️  캐시

- 값비싼 연산 결과 or 자주 참조되는 데이터를 메모리 안에 두고 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소
- 애플리케이션의 성능은 **데이터베이스를 얼마나 자주 호출**하느냐에 크게 좌우된다.
    - 캐시는 그런 문제를 완화할 수 있다.

### 캐시 계층

- 데이터가 잠시 보관되는 곳 → 데이터베이스보다 훨씬 빠름
- 장점 3콤보! ⇒ 성능 개선 + 데이터베이스 부하 줄임 + 캐시 계층의 규모를 “독립적으로” 확장
- 캐시를 두는 다양한 방법 중 하나 예시
    - 웹 서버가 데이터를 캐시에 요청
        - 캐시에 해당 데이터가 있으면 ⭕ → 캐시에서 반환
        - 캐시에 해당 데이터가 없으면 ❌ →  데이터베이스 질의 → 데이터를 캐시에 저장 → 클라이언트에 반환

### 캐시 전략

### **캐시 읽기 전략 (Read Cache Strategy)**

### 1) **Look Aside 패턴**

---

- Cache Aside 패턴이라고도 불림.
- 데이터를 찾을때 우선 캐시에 저장된 데이터가 있는지 **우선적으로 확인**하는 전략.
- 만일 캐시에 데이터가 없으면 DB에서 조회함.
- 반복적인 읽기가 많은 호출에 적합.
- 캐시와 DB가 분리되어 가용되기 때문에 원하는 데이터만 별도로 구성하여 캐시에 저장
    - 캐시와 DB가 분리되어 가용되기 때문에 캐시 장애 대비 구성이 되어있음. 만일 redis가 다운 되더라도 DB에서 데이터를 가져올수 있어 서비스 자체는 문제가 없음.
- 단점
    - 대신에 캐시에 붙어있던 connection이 많았다면, redis가 다운된 순간 순간적으로 DB로 몰려서 부하 발생.
    - Cache Store와 Data Store(DB)간 정합성 유지 문제가 발생

!https://blog.kakaocdn.net/dn/2i45c/btrQOQ1Fefc/fhqk6Kf1VY57pga3Xd1ZFK/img.png

### 2) **Read Through 패턴**

---

- `캐시에서만 데이터를 읽어오는 전략` (inline cache)
- Look Aside 와 비슷하지만 **데이터 동기화를 라이브러리 또는 캐시 제공자에게 위임**하는 방식이라는 차이가 있음.
    - ReadThrough = 캐시에 업데이트 → 캐시에서 데이터 가져옴
    - Look Aside ****= 먼저 DB에서 데이터  가져옴 → 캐시에 업데이트
- 단점
    - 따라서 데이터를 조회하는데 있어 전체적으로 속도가 느림.
    - 또한 데이터 조회를 전적으로 캐시에만 의지하므로, redis가 다운될 경우 서비스 이용에 차질이 생길수 있음. → redis과 같은 구성 요소를 **Replication 또는 Cluster로 구성**하여 가용성을 높여야 한다
- 장점
    - 직접적인 데이터베이스 접근을 최소화하고 Read 에 대한 소모되는 자원을 최소화할 수 있다.
    - 대신에 캐시와 DB간의 데이터 동기화가 항상 이루어져 데이터 정합성 문제에서 벗어날수 있음

!https://blog.kakaocdn.net/dn/ekuWqE/btrQPeuqqV0/Q7KsW68Hr4uG4nq5zjzCAk/img.png

### **캐시 쓰기 전략 (Write Cache Strategy)**

### 1) **Write Back 패턴**

---

- Write Back 방식은 데이터를 저장할때 DB가 아닌 먼저 캐시에 저장하여 모아놓았다가 특정 시점마다 DB로 쓰는 방식으로 캐시가 일종의 **Queue 역할**을 겸하게 된다.
    - **캐시에 모아서 일정 주기 배치 작업을 통해 DB에 반영**
- Write Behind 패턴 이라고도 불림. (나중에 쓰기)
- 캐시와 DB 동기화를 비동기하기 때문에 동기화 과정이 생략
- 장점
    - 캐시에 모아놨다가 DB에 쓰기 때문에 쓰기 쿼리 회수 비용과 부하를 줄일 수 있음
    - Write가 빈번하면서 Read를 하는데 많은 양의 Resource가 소모되는 서비스에 적합
    - 데이터 정합성 확보
- 단점
    - 자주 사용되지 않는 불필요한 리소스 저장.
    - 캐시에서 오류가 발생하면 데이터를 영구 소실함.

!https://blog.kakaocdn.net/dn/bx8ccX/btrQOQsNl1R/PqAPn7DApmyN65sJDyB5k1/img.png

### 2) **Write Through 패턴**

---

- 데이터베이스와 Cache에 **`동시에 데이터를 저장`**하는 전략
    - Write Through 패턴은 Cache Store에도 반영하고 Data Store에도 동시에 반영하는 방식이다. (Write Back은 일정 시간을 두고 나중에 한꺼번에 저장)
- 데이터를 저장할 때 먼저 캐시에 저장한 다음 바로 DB에 저장 (모아놓았다가 나중에 저장이 아닌 바로 저장)
- Read Through 와 마찬가지로 DB 동기화 작업을 캐시에게 위임
- 장점
    - DB와 캐시가 항상 동기화 되어 있어, 캐시의 데이터는 항상 최신 상태로 유지 → 캐시와 백업 저장소에 업데이트를 같이 하여 데이터 일관성을 유지할 수 있어서 안정적
        - ⇒ 데이터 유실이 발생하면 안 되는 상황에 적합
- 단점
    - 매 요청마다 두번의 Write가 발생하게 됨으로써 빈번한 생성, 수정이 발생하는 서비스에서는 성능 이슈 발생
    - 무조건 일단 Cache Store에 저장하기 때문에 캐시에 넣은 데이터를 저장만 하고 사용하지 않을 가능성이 있어서 리소스 낭비 가능성이 있다.
    - 기억장치 속도가 느릴 경우, 데이터를 기록할 때 CPU가 대기하는 시간이 필요하기 때문에 성능 감소
    - 자주 사용되지 않는 불필요한 리소스 저장.

!https://blog.kakaocdn.net/dn/DLlbo/btrQT53hVhs/aXMNdXgjGYnNWTlnZQsLr0/img.png

### 3) **Write Around 패턴**

- 모든 데이터는 DB에 저장 (캐시를 갱신하지 않음)
- Cache miss가 발생하는 경우에만 DB와 캐시에도 데이터를 저장
- 따라서 캐시와 DB 내의 데이터가 다를 수 있음 (데이터 불일치)
- Write Around 패턴은 속도가 빠르지만, cache miss가 발생하기 전에 데이터베이스에 저장된 데이터가 수정되었을 때, 사용자가 조회하는 cache와 데이터베이스 간의 데이터 불일치가 발생하게 된다.
- 따라서 데이터베이스에 저장된 데이터가 수정, 삭제될 때마다, Cache 또한 삭제하거나 변경해야 하며, Cache의 expire를 짧게 조정하는 식으로 대처해야 한다.

!https://blog.kakaocdn.net/dn/bczXKV/btrQTWMk5OZ/1ugHbWBOyyEE9SzkXJ2It1/img.png

> Tip
>
>
> Write Around 패턴은 주로 Look aside, Read through와 결합해서 사용된다.
>
> 데이터가 한 번 쓰여지고, 덜 자주 읽히거나 읽지 않는 상황에서 좋은 성능을 제공한다.
>

### 캐시 사용 시 유의할 점

- 적용 **상황**
    - ⇒ 데이터 갱신은 자주 일어나지 않지만, 참조는 빈번하게 일어날 때
- **어떤 데이터**를 캐시에 둘까?
    - ⇒ 영속적으로 보관할 데이터는 제외하자! ( 캐시는 데이터를 휘발성 메모리에 두기 때문에 캐시 서버가 재시작되면 데이터는 사라짐)
- 캐시에 보관된 데이터는 어떻게 **만료**?
    - 정책을 마련하여 적당한 만료 기간을 설정하여 데이터가 남아있다가 삭제되게 하자
    - 만료 기간이 길 경우 → 원본과 차이가 날 가능성 높아짐
    - 만료 기간이 짧을 경우 → 데이터베이스를 너무 자주 읽게 된다.
- **일관성**은 어떻게 유지할까?
    - 데이터 저장소의 원본과 캐시 내에 사본이 같은지 여부
- 장애에는 어떻게 대처?
    - 캐시 서버가 1대라면 장애가 전체 시스템의 동작을 중단시켜버릴 수 있기 때문에 단일 장애 지점이 될 수 있다.
    - → 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
- 캐시 메모리는 얼마나 크게 잡을 것인가?
    - 캐시 메모리가 너무 작으면 → 액세스 패턴에 따라서는 데이터가 자주 방출되어 캐시의 성능이 떨어짐 → 과할당을 하자!
- 데이터 방출! 정책이란?
    - 캐시가 꽉 차버렸을 때 기존 데이터 중 어떤 데이터를 내보내야할 것인가?
    - 1) 고인물 내보내기 → LRU
    - 2) 사용 빈도 낮은 거 내보내기 → LFU
    - 3) FIFO → 가장 먼저 캐시에 들어온 데이터를 가장 먼저 내보내기

# ✔️  콘텐츠 전송 네트워크 CDN

- 정적 콘텐츠(이미지, 비디오, CSS 등)를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크
    - 사용자가 요청하는 지리적 위치와 서버의 지리적 위치 차이로 인해 로딩 속도의 차이로 이어진다. 이를 개선하기 위해 CDN을 사용한다.
- 과정
    - 1) 사용자가 image.png에 접근하기위해 CDN 서비스 사업자가 제공한 URL을 이용함
    - 2) CDN 서버의 캐시에 해당하는 이미지가 없는 경우 → 서버(웹 서버 or S3)에 요청하여 파일을 가져온다. 이때 응답 헤더에 TTL값이 들어있어 해당 시간동안 CDN에 캐시되어 있다.
    - 3) CDN 서버에 이미지가 있다면 바로 반환

- 고려해야할 사항
    - 비용, 적절한 만료 시한 설정, 장애 대처 방안, 아직 만료되지 않은 콘텐츠라고 하더라도 무효화하는 방안

# ✔️  무상태 웹 계층

- 수평적으로 확장하기 위해 상태 정보(사용자 세션 데이터 등)를 웹 계층에서 제거
    - → 대신 상태 정보를 관계형 데이터베이스나 NoSQL 과 같은 지속성 저장소에 보관
- 만약 상태 정보 의존적인 아키텍처라면 여러 서버가 있을 때 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송해야할 것이다.
    - 로드 밸런서의 고정 세션이라는 기능으로 이 문제를 해결할 수 있지만 로드밸런서에 부담을 준다는 단점이 있다.
- 무상태 아키텍처
    - 상태 정보를 **별도의 공유 저장소(shared storage)**로부터 데이터를 저장
    - 웹 서버로부터 물리적으로 분리됨
    - 이 공유 저장소는 Memcached나 Redis와 같은 캐시 시스템일수도 있고 NoSQL 일수도 있다. → 규모 확장 간편하기 때문
    - **자동 규모 확장(autoscaling)**이 가능 → 상태 정보를 신경 쓸 필요 없이(따로 분리 되었으므로) 트래픽 양에 따라 웹 서버를 넣거나 빼기 가능

# ✔️  데이터 센터

- 데이터 센터란?
    - 데이터 센터는 컴퓨팅 시스템 및 관련 하드웨어 장비를 저장하는 물리적 위치입니다. 여기에는 서버, 데이터 스토리지 드라이브 및 네트워크 장비와 같이 IT 시스템에 필요한 컴퓨팅 인프라가 포함됩니다. 모든 회사의 디지털 데이터를 저장하는 물리적 시설입니다.
- 데이터센터 서비스 유형
    - 온프레미스
        - 온프레미스 데이터 센터는 회사의 민감한 데이터와 중요 애플리케이션을 저장하는 회사가 전적으로 소유한 데이터 센터입니다. 회사가 데이터 센터를 설치하고, 데이터 센터의 지속적인 운영을 관리하고, 장비를 구매 및 유지 관리
    - 콜로케이션
        - 콜로케이션 시설은 서버, 랙 및 기타 컴퓨팅 하드웨어를 설치할 공간을 임대할 수 있는 대규모 데이터 센터 시설
    - 클라우드
        - 클라우드 데이터 센터에서는 공간과 인프라를 모두 대여할 수 있습니다. 클라우드 제공업체는 보안과 규정 준수가 완벽하게 보장되는 상태로 대규모 데이터 센터를 유지 관리합니다. 사용량과 결제 방식을 보다 유연하게 결정할 수 있는 다양한 서비스를 이용하여 이 인프라에 액세스
- **지리적 라우팅(geoDNS-routing 또는 geo-routing)**
    - 단일서버와 다르게 세계 여러 지역 사용자의 요청을 처리하는 글로벌 서비스의 시스템은 그와 상반되게 확장성을 위해 다양한 기술과 도구들을 사용
    - 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스
    - GeoDNS는 DNS 서비스로 고객의 위치에 기반하여 도메인에 대한 ip 매핑을 진행한다. 유럽에서 접근하는 고객은 유럽에 존재하는 서버의 ip로, 미국에서 접근하는 고객은 미국 서버의 ip로 전달하여 네트워크 latency를 낮추고 부하도 분산할 수 있게 된다.
    - 기본 DNS는 단순한 도메인-IP 매핑을 제공하는 반면, geoDNS는 사용자의 지리적 위치를 고려하여 최적의 서버로 연결하는 더 발전된 서비스를 제공한다.
- 데이터센터 중 하나에 장애가 생기면 트래픽이 한쪽으로 쏠릴 수 있다. → 다중 데이터 센터 아키텍처가 필요하다 → 전 세계 어디서도 쾌적하게 사용할 수 있다.
- 다중 데이터센터 아키텍처에 대한 난제 해결 필요
    - **트래픽 우회:** 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾는다. geoDNS는 사용자에게서 가장 가까운 데이터센터로 트래픽을 보낼 수 있도록 해준다.
    - **데이터 동기화(synchronization):** 데이터 센터마다 별도로 데이터베이스를 사용하고 있는 상황이라면, 장애가 자동으로 복구되어(failover) 트래픽이 다른 데이터베이스로 우회된다 해도, 해당 데이터센터에는 찾는 데이터가 없을 수 있다. 이런 상황을 막는 보편적 전략은 데이터를 **여러 데이터센터에 걸쳐 다중화**하는 것이다.
    - **테스트와 배포:** 여러 데이터 센터에서 웹 사이트 혹은 애플리케이션을 테스트 해보는게 중요하다. 또한 자동화된 배포 도구를 사용하여 모든 데이터 센터에 동일한 서비스가 설치되도록 한다.

# ✔️  메시지 큐

- 시스템을 더 큰 규모로 확장하기 위해서 → 시스템의 컴포넌트를 분리하여 각기 독립적으로 확장하는 것이 필요! → “메시지 큐 전략”을 통해 이를 가능하게 한다.
- 메시지 큐는 메시지의 **`무손실`**을 보장하는 비동기 통신을 지원하는 컴포넌트
    - 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관
- 메시지의 버퍼 역할 , 비동기적으로 전송
- 기본 아키텍쳐
    - 1) 생산자 producer(또는 발행자)라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publisher)한다.
    - 2) 큐에는 보통 소비자 혹은 구독자라 불리는 서비스 혹은 서버가 연결되어 있는데 메시지를 받아 그에 맞는 동작을 수행한다.

- 장점
    - 서비스 또는 서버 간 결합이 느슨해져서 → 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.
    - 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있고 소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.
        - 만약 카톡으로 내가 “안녕”이라고 보냈을 때 상대방이 다운되어 있다면 요청이 안가는데 중간에 큐가 있으면 보낼 수 있다.
        - 예를 들어, 사진 보정 어플리케이션이라면 보정 시간이 오래걸리는 프로세스이다. →  비동기적으로 처리하면 편하다.

          ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/a0b903dc-d00f-4dae-b3c5-eecbc93627d4/Untitled.png)

            - 보정 작업을 메시지 큐에 꺼내어 비동기적으로 완료한다.
            - 이렇게 하면 생산자와 소비자 서비스의 규모는 각기 독립적으로 확장 가능




# ✔️ 로그, 메트릭 그리고 자동화

- 소규모 서비스에서는 **로그, 메트릭(metric), 자동화(automation)**은 좋지만 필수는 아니다. 하지만 사업 규모가 커지면 이런 도구에도 투자해야한다.
- 로그
    - 에러 로그를 모니터링 하는 것은 중요
    - 시스템의 오류와 문제를 보다 쉽게 찾아낼 수 있음
    - 서버 단위로 로그를 모니터링하는 것도 좋지만, **로그를 하나로 모아주는 도구를 활용**하면 더 편리하게 검색, 조회 할 수 있음
- 메트릭
    - 메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보를 얻을수도 있고, 시스템의 현재 상태를 손쉽게 파악할 수 도 있음
        - 호스트 단위 메트릭: CPU, 메모리, 디스크 I/O에 관한 메트릭
        - 종합(aggregated) 메트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능
        - 핵심 비즈니스 메트릭: 일별 활성 사용자(daily active user), 수익, 재방문(retention) 같은 것들
- 자동화
    - 시스템이 크고 복잡해지면, 생산성을 위해 자동화 도구를 활용해야한다. 빌드, 테스트, 배포 등의 절차를 자동화하여 개발 생산성을 향상 시킬 수 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/8deb49dc-c417-430d-b0a1-3f2e2926512e/Untitled.png)

# ✔️  데이터베이스의 규모 확장

- 저장할 데이터가 많아지면 → 데이터베이스에 대한 부하도 증가 → 데이터베이스를 증설할 방법 찾기!
- 데이터베이스 규모 확장 방법
    - 1) 수직적 규모 확장
        - 고성능의 자원(CPU, RAM, 디스크 등)을 증설하는 방법
            - 서버 하드웨어를 무한 증설할 수 없으므로 한계가 존재한다.
            - SPOF(단일 장애 지점)로 인한 위험성이 크다.
            - 비용 많이 든다.
    - 2) 수평적 규모 확장
        - 더 많은 서버를 추가한다.
        - 샤딩 = 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할함
            - 같은 스키마를 쓰지만 보관되는 데이터에 중복이 없다.
        - “샤딩 키를 어떻게 정하느냐” ⇒ 샤딩 전략을 구현할 때 중요한 것임
            - 샤딩키 == 파티션 키 == **데이터가 어떤 샤드에 저장되는지 결정하는 하나 이상의 컬럼으로 구성됨**
            - 샤딩 키를 통해 올바른 데이터베이스에 질의를 보내어 데이터 조회나 변경을 처리할 수 있음
            - 샤딩 키를 정할 때는 데이터를 고르게 분할할 수 있도록 하는 게 가장 중요
        - 샤딩을 적용할 경우 생기는 문제점
            - **1) 데이터의 재 샤딩(resharding)**
                - 재 샤딩이 필요한 경우 1) **데이터가 너무 많아져** 하나의 샤드로는 감당이 어려운 경우
                - 재 샤딩이 필요한 경우 2) **균등하게 데이터 분포가 되지 않아** 특정 샤드에 데이터가 몰려 할당된 공간 소모가 다른 샤드에 비해 빠르게 진행될 때
                - 해결 방법 = 샤드 키를 계산하는 함수를 변경하고 데이터를 재 배치해야하기 ex)  **안정 해시(consistent hashing)** 기법
            - **2) 유명인사(celebrity) 문제 == 핫스팟 키(hotspot key) 문제**
                - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
                - 유명 인사 유저가 모두 한 샤드에 집중적으로 저장되어 있다면 해당 샤드만 큰 과부하가 걸리게 될 것
                - 해결 방법 = 유명인사 각각에 샤드 하나씩을 할당해야 할 수도 있고, 더 잘게 샤드를 쪼개기
            - 3) **조인과 비정규화(join and de-normalization)**
                - 하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기 힘들어진다.
                - 해결 방법 = 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 함
                    - 예시
                        - **데이터베이스 샤딩**: 사용자 정보(**`Users`**)와 주문 정보(**`Orders`**)가 각기 다른 샤드에 저장되어 있습니다.
                        - **조인의 어려움**: 한 사용자의 모든 주문 내역을 조회할 때, **`Users`** 샤드와 **`Orders`** 샤드 간의 데이터를 조인해야 하는데, 이는 네트워크 오버헤드를 발생시키고 성능 저하의 원인이 됩니다.
                        - **비정규화 구현**: **`Users`** 테이블에 사용자의 주요 주문 정보를 포함시켜, 주문 정보가 필요할 때 다른 샤드로의 요청 없이 즉시 데이터를 가져올 수 있도록 합니다.

- 참고하기 좋은 글

  https://kadensungbincho.tistory.com/78
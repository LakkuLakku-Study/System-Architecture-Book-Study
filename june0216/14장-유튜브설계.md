# 1단계. 문제 이해 및 설계 범위 확정

- 어떤 기능이 가장 중요?
    - 비디오를 올리고 시청하는 기능
- 어떤 클라이언트?
    - 모바일 앱, 웹 브라우저, 스마트 TV
- 일간 능동 사용자 수
    - 5백만
- 평균 소비 시간
    - 30분
- 다국어 지원?
    - 모든 언어 가능
- 어떤 비디오 해상도?
    - 현존하는 비디오 종류와 해상도 대부분 지원
- 암호화 필요?
    - 네
- 클라우드 (ex AWS, GCP) 가능?
    - 네

구독, 댓글 등의 부가적인 기능이 아니라  `비디오 스트리밍 서비스` 설계에 초점을 맞출 예정

- 빠른 비디오 업로드
- 원활한 비디오 재생
- 재생 품질 선택 기능
- 낮은 인프라 비용 `infrastructure cost`
- 높은 가용성과 규모 확장성, 그리고 안정성
- 지원 클라이언트: 모바일 앱, 웹 브라우저, 그리고 스마트 TV

### 개략적 규모 추정

- 일간 능동 사용자`DAU` 수는 5백만(5million)
- 한 사용자는 하루에 평균 5개의 비디오 시청
- 10%의 사용자가 하루에 1비디오 업로드
- 비디오 평균 크기는 300MB
- 비디오 저장을 위해 매일 새로 요구되는 저장 용량 : 5백만 * 10% * 300MB ⇒ 150TB
- CDN 비용
    - 클라우드 CDN을 통해 비디오를 서비스할 경우 CDN에서 나가는 데이터의 양에 따라 과금
    - 아마존의 클라우드프론트`CloudFront`를 CDN 솔루션으로 사용할 경우, 100% 트래픽이 미국에서 발생한다고 가정하면 1GB당 $0.02의 요금이 발생.
        - 문제를 단순화하기 위해 비디오 스트리밍 비용만 따지도록 가정
    - 매일 발생하는 요금은
        - 5백만 사용자 * 5개 비디오 * 0.3GB 비디오 크기 * $0.02 CDN 비용 ⇒ $150,000
    - 이는 만만치 않은 비용이므로 줄이는 방법을 추후 알아보겠다.

# 2단계. 개략적 설계안 제시 및 동의 구하기

- 직접 모든 걸 설계하는 게 아니라 클라우드 서비스를 이용하는 이유?
    - 시스템 설계 면접은 모든 것을 밑바다부터 만드는 것과는 관계가 없다.
        - 주어진 시간 안에 적절한 기술을 골라 설계를 마치는 것이 중요!
    - 규모 확장이 쉬운 BLOB 저장소 나 CDN을 만드는 것은 지극히 복잡할 뿐 아니라 많은 비용이 드는 일이다.
        - 넷플릭스는 아마존의 클라우드 서비스를 사용하고, 페이스북은 아카마이(Akamai)의 CDN을 이용
    

## 개략적 시스템 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/5ad21094-2f05-450a-9306-283eea1d1c84/Untitled.png)

개략적으로 보면 이 시스템은 `단말(client)`, `CDN`, `API 서버` 세 개의 컴포넌트로 구성

- **`단말 (client)`**
    - 컴퓨터, 모바일 폰, 스마트 TV를 통해 유튜브를 시청할 수 있다.
- **`CDN`**
    - 비디오는 CDN에 저장한다.
    - 재생 버튼을 누르면 CDN으로부터 스트리밍이 이루어진다.
- **`API 서버`**
    - 비디오 스트리밍을 제외한 모든 요청은 API 서버가 처리.
    - 피드 추천(Feed recommendation), 비디오 업로드 URL 생성, 메타데이터 데이터베이스와 캐시 갱신, 사용자 가입 등등이 API 서버가 처리하는 작업

## 1) 비디오 업로드 절차

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/6984826d-32a5-4be5-a543-6f0163d0ab97/Untitled.png)

- 사용자
    - 컴퓨터나 모바일 폰, 혹은 스마트 TV를 통해 유튜브를 시청하는 이용자다.
- 로드밸런서(load balancer)
    - API 서버 각각으로 고르게 요청을 분산하는 역할을 담당한다.
- API 서버
    - 비디오 스트리밍을 제외한 다른 모든 요청을 처리한다.
- 메타데이터 데이터베이스(metadata db)
    - 비디오의 메타데이터를 보관한다.
    - 샤딩과 다중화를 적용하여 성능 및 가용성 요구사항을 충족한다.
- 메타데이터 캐시(metadata cache)
    - 성능을 높이기 위해 비디오 메타데이터와 사용자 객체 (user object)는 캐시 한다.
- 원본 저장소(original storage)
    - 원본 비디오를 보관할 대형 이진 파일 저장소 (BLOB, 즉 Binary Large Object storage) 시스템이다.
    - 이진 데이터를 하나의 개체로 보관하는 데이터베이스 관리 시스템
        - 대용량 데이터 처리: 텍스트, 이미지, 비디오, 오디오와 같은 대형 파일을 저장할 수 있습니다.
        - 유연한 데이터 저장: 구조화된 데이터뿐만 아니라 비구조화된 데이터도 저장할 수 있습니다.
        - 효율적인 관리: 데이터의 저장, 접근, 관리가 효율적으로 이루어지도록 설계되어 있습니다.
        - 동작과정
            
            동영상 데이터를 BLOB 스토리지에 저장하고 접근하는 과정을 예시를 통해 설명하겠습니다.
            
            ### 1. 동영상 데이터 업로드
            
            ### 1.1 동영상 파일 준비
            
            사용자가 동영상 파일을 업로드하려고 합니다. 예를 들어, 파일 이름은 `movie.mp4`입니다.
            
            ### 1.2 업로드 요청
            
            사용자가 웹 애플리케이션을 통해 동영상 파일을 업로드합니다. 웹 애플리케이션은 동영상 파일을 HTTP 요청을 통해 서버로 전송합니다.
            
            ```java
            java코드 복사
            // Java로 작성된 예시 코드 (Spring Framework 사용)
            @RestController
            public class VideoUploadController {
            
                @PostMapping("/upload")
                public ResponseEntity<String> uploadVideo(@RequestParam("file") MultipartFile file) {
                    try {
                        // 파일을 BLOB 스토리지에 저장하는 서비스 호출
                        blobStorageService.saveFile(file);
                        return ResponseEntity.ok("File uploaded successfully.");
                    } catch (Exception e) {
                        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Failed to upload file.");
                    }
                }
            }
            
            ```
            
            ### 1.3 서버에서 파일 수신
            
            서버는 파일을 수신한 후, BLOB 스토리지 서비스로 전달합니다. 이 서비스는 파일을 적절한 위치에 저장하고 메타데이터를 관리합니다.
            
            ### 2. 동영상 데이터 저장
            
            ### 2.1 BLOB 스토리지에 파일 저장
            
            BLOB 스토리지 서비스는 파일을 저장소에 저장합니다. 파일은 대개 고유한 식별자와 함께 저장되며, 이를 통해 나중에 쉽게 접근할 수 있습니다.
            
            ```java
            java코드 복사
            public class BlobStorageService {
            
                public void saveFile(MultipartFile file) throws IOException {
                    // BLOB 스토리지 클라이언트를 사용하여 파일 저장
                    String blobId = UUID.randomUUID().toString();
                    BlobContainerClient containerClient = new BlobServiceClientBuilder().connectionString(connectionString).buildClient().getBlobContainerClient(containerName);
                    BlobClient blobClient = containerClient.getBlobClient(blobId);
            
                    // 파일을 BLOB 스토리지에 업로드
                    blobClient.upload(file.getInputStream(), file.getSize(), true);
                }
            }
            
            ```
            
            ### 2.2 메타데이터 저장
            
            파일과 함께 파일의 메타데이터 (예: 파일 이름, 업로드 시간, 파일 크기 등)도 저장됩니다. 이 정보는 나중에 파일을 검색하고 관리하는 데 사용됩니다.
            
            ### 3. 동영상 데이터 접근
            
            ### 3.1 동영상 요청
            
            사용자가 동영상을 시청하려고 합니다. 웹 애플리케이션을 통해 동영상 파일을 요청합니다. 예를 들어, 파일 ID가 `1234`인 동영상을 요청합니다.
            
            ```java
            java코드 복사
            // 동영상 요청을 처리하는 컨트롤러
            @RestController
            public class VideoDownloadController {
            
                @GetMapping("/video/{id}")
                public ResponseEntity<StreamingResponseBody> getVideo(@PathVariable String id) {
                    InputStream videoStream = blobStorageService.getFileStream(id);
                    return ResponseEntity.ok()
                        .contentType(MediaType.valueOf("video/mp4"))
                        .body(outputStream -> {
                            IOUtils.copy(videoStream, outputStream);
                        });
                }
            }
            
            ```
            
            ### 3.2 서버에서 파일 접근
            
            서버는 BLOB 스토리지에서 파일을 검색하고, 파일 스트림을 생성합니다. 이를 통해 사용자가 스트리밍 방식으로 동영상을 시청할 수 있습니다.
            
            ```java
            java코드 복사
            public class BlobStorageService {
            
                public InputStream getFileStream(String id) {
                    BlobContainerClient containerClient = new BlobServiceClientBuilder().connectionString(connectionString).buildClient().getBlobContainerClient(containerName);
                    BlobClient blobClient = containerClient.getBlobClient(id);
            
                    // BLOB 스토리지에서 파일 스트림 가져오기
                    return blobClient.openInputStream();
                }
            }
            
            ```
            
            ### 4. 동영상 데이터 스트리밍
            
            ### 4.1 파일 스트림 전송
            
            서버는 클라이언트에게 파일 스트림을 전송합니다. 클라이언트는 스트리밍 방식으로 동영상을 재생할 수 있습니다.
            
            ### 4.2 클라이언트에서 동영상 재생
            
            사용자의 웹 브라우저나 동영상 플레이어는 서버로부터 받은 파일 스트림을 재생합니다. 동영상은 네트워크를 통해 실시간으로 전송되며, 사용자에게 끊김 없는 재생 경험을 제공합니다.
            
            ```html
            html코드 복사
            <!-- HTML로 작성된 동영상 재생 예시 -->
            <video controls>
              <source src="/video/1234" type="video/mp4">
              Your browser does not support the video tag.
            </video>
            
            ```
            
- 트랜스코딩 서버(transcoding server)
    - 비디오를 인코딩하는 절차
    - 비디오의 포맷(MPEG, HLS 등)을 변환하는 절차다.
    - 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 필요하다.
- 트랜스코딩 비디오 저장소(transcoded storage)
    - 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소다.
- CDN
    - 비디오를 **캐시하는 역할**을 담당한다.
    - 사용자가 재생 버튼을 누르면 비디오 스트리밍은 CDN을 통해 이루어진다.
- 트랜스코딩 완료 큐
    - 비디오 트랜스코딩 완료 이벤트를 보관할 메시지 큐
- 트랜스코딩 완료 핸들러 (completion handler)
    - 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타 데이터캐시와 데이터베이스를 갱신할 작업 서버들이다.

## 비디오 업로드가 어떻게 처리되는가?

비디오 업로드는 `비디오 업로드` 와 `비디오 메타데이터 갱신`(메타 데이터에는 비디오 URL, 크기, 해상도, 포맷, 사용자 정보가 포함) 두 프로세스가 병렬적으로 수행된다.

### 프로세스 A: 비디오 업로드

1. 비디오를 **`원본 저장소`**에 업로드
2. **`트랜스코딩 서버`**는 원본 저장소에서 해당 비디오를 가져와 트랜스코딩 시작
3. 트랜스 코딩이 완료되면 아래 두 절차가 `병렬적`으로 수행
    
    3a.1. 완료된 비디오를 트랜스 코딩 비디오 저장소로 업로드
    
    3b. 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣는다. 
    
    3a.1. 트랜스코딩이 끝난 비디오를 CDN에 올린다. 
    
    3b.1. 완료 핸들러가 이벤트 데이터를 큐에서 꺼낸다. 
    
    3b.1.a, 3b.1.b. 완료 핸들러가 메타데이터 데이터베이스와 캐시를 갱신
    
4. API 서버가 단말에게 비디오 업로드가 끝나서 스트리밍 준비가 되었음을 알림

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/a6003077-280a-4a51-9caa-a999afcaccf9/Untitled.png)

### 프로세스 B: 메타데이터 갱신

- 원본 저장소에 파일이 업로드 되는 동안 단말 병렬적으로 비디오 메타데이터 갱신 요청을 `API 서버`에 보냄
    - 이 요청에 포함된 메타데이터에는 이름, 크기, 포맷 등의 정보가 들어있다.
- API 서버는 이 정보로 메타데이터 캐시와 데이터베이스를 업데이트 한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/1eb852a6-125b-4222-9e79-0086d10b10e8/Untitled.png)

## 2) 비디오 스트리밍 절차

- 스트리밍
    - 클라이언트 장치가 원격지의 비디오로부터 지속적으로 비디오 스트림을 전송받아 영상을 재생하는 것이다.
- `스트리밍 프로토콜(streaming protocol)`
    - 비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신방법
- **널리 사용되는 스트리밍 프로토콜**
    - `MPEG-DASH` :
        - MPEG(Moving Picture Experts Group)
        - DASH(Dynamic Adaptive Streaming over HTTP)
    - 애플(Apple) `HLS`
        - HLS(HTTP Live Streaming)
    - `마이크로소프트 스무드 스트리밍(Microsoft Smooth Streaming)`
    - `어도비 HTTP 동적 스트리밍(Adobe HTTP Dynamic Streaming, HDS)`
- 프로토콜마다 지원하는 비디오 인코딩이 다르고 플레이어도 다르므로 비디오 스트리밍 서비스를 설계할 때에는 서비스의 용례에 맞는 프로토콜을 잘 골라야 함.

- 비디오는 `CDN`에서 바로 스트리밍
    - 사용자의 단말에 가장 가까운 CDN 에지 서버가 비디오 전송을 담당한다.
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/932cd2f1-b277-4d4b-a152-7ce2e6f3b3a9/Untitled.png)
        

# 3단계. 상세 설계

- 이번에는 “비디오 업로드”와 “비디오 스트리밍” 부분을 최적화하는 방안과 오류 처리 메커니즘에 대해 다룬다.

## 비디오 트랜스 코딩

- 비디오가 단말에서 순조롭게 재생되려면 호환되는 **비트레이트와 포맷**으로 저장되어야 한다.
    - 비트레이트 = 비디오를 구성하는 비트가 얼마나 빨리 처리되어야 하는지 나타내는 단위
    - 비트레이트가 높다 == 고화질 비디오
- 비디오 트랜스 코딩
    - 비디오 파일을 한 형식에서 다른 형식으로 변환하는 프로세스
    - 해상도, 비트 전송률, 코덱 등의 비디오 파일 속성을 변경

**비디오 트랜스코딩이 중요한 이유**

1. 가공되지 않은 원본 비디오(raw video)는 저장 공간을 많이 차지
2. 상당 수의 단말과 브라우저는 특정 종류의 비디오 포맷만 지원 
    
    → 호환성 문제를 해결하려면 하나의 비디오를 여러 포맷으로 인코딩해 두는 것이 바람직하다 
    
3. 사용자에게 끊김 없는 고화질 비디오 재생을 보장하려면, 
    1. 네트워크 대역폭이 충분하지 않은 사용자에게는 저화질 비디오를, 
    2. 대역폭이 충분한 사용자에게는 고화질 비디오를 보내자
4. 모바일 단말의 경우 네트워크 상황이 수시로 달라질 가능성이 있다. 
    1. 비디오가 끊김 없이 재생되도록 하기 위해서는 비디오 화질을 자동으로 변경하거나 수동으로 변경할 수 있도록 지원하자

**인코딩 포맷**

1. `컨테이너(container)` 
    1. 비디오 파일, 오디오, 메타데이터를 담는 바구니 같은 것. 
    2. .avi, .mov, .mp4 같은 파일 확장자를 보고 컨테이너 포맷 확인 가능
2. `코덱(codec)` 
    1. 비디오 화질은 보존하면서 파일 크기를 줄일 목적으로 고안된 **압축 및 압축 해제 알고리즘.** 
    2. 가장 많이 사용되는 비디오 코덱으로는 H.264, VP9, HEVC

## 유향 비순환 그래프(DAG) 모델

- 비디오를 트랜스코딩하는 것은 컴퓨팅 자원을 많이 소모할 뿐만 아니라 시간이 많이 드는 작업이다.
    - 콘텐츠 창작자는 각자 자기만의 비디오 프로세싱을 요구사항을 갖고 있다.
        - 어떤 사람은 비디오 위에 워터마크(watermark)를 표시하고 싶어 할 수 있고
        - 어떤 사람은 섬네일 이미지를 자기가 손수 만들어 쓰고 싶어 할 수 있고
        - 어떤 사람은 고화질 비디오를 선호하는 반면 또 다른 어 떤 이는 저화질 비디오도 충분하다고 생각할 것 이다.
- 각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하는 한편 처리 과정의 병렬성을 높이기 위해서는 적절한 수준의 추상화를 도입하여 클라이언트 프로그래머로 하여금 실행할 작업`task`을 손수 정의할 수 있도록 해야 함
    - ex) 페이스북의 스트리밍 비디오 엔진은 유향 비순환 그래프 프로그래밍 모델을 도입하여 작업을 단계별로 배열할 수 있도록 하고 있다.

**비디오 트랜스코딩을 위해 본 설계안이 채택한 DAG 모델**

!https://velog.velcdn.com/images/ony/post/49a0133c-5a61-4d74-bb18-0b2b9c152209/image.png

원본 비디오는 비디오, 오디오, 메타데이터의 세 부분으로 나뉘어 처리

**비디오 부분에 적용되는 작업**

- 검사(inspection)
    - 좋은 품질의 비디오인지, 손상은 없는지 확인하는 작업 이다.
- 비디오 인코딩(video encoding)
    - 비디오를 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩하는 작업이다.
- 썸네일(thumbnail)
    - 사용자가 업로드한 이미지나 비디오에서 자동 추출된 이미지 썸네일을 만드는 작업
- 워터마크(watermark)
    - 비디오에 대한 식별정보를 이미지 위에 오버레이 (overlay) 형태로 띄워 표시하는 작업이다.

## 비디오 트랜스코딩 아키텍처

- 클라우드 서비스를 활용한 트랜스코딩 아키텍처

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/058cdf98-0af9-46d4-a257-2dcfe5e7f520/Untitled.png)

이 아키텍처는 다섯 개의 주요 컴포넌트로 구성된다.

- 전처리기(preprocessor)
- DAG 스케줄러
- 자원 관리자(resource manager)
- 작업 실행 서버(resource worker)
- 임시 저장소(temporary storage)

이 아키텍처가 동작한 결과로 인코딩 된 비디오가 만들어진다.

### 전처리기

**전처리기가 하는 일**

1. `비디오 분할(video splitting)` 
    - 비디오 스트림을 `GOP(Group of Picture)`라고 불리는 단위로 쪼갬.
        - GOP는 특정 순서로 배열된 프레임(frame) 그룹.
    - 하나의 GOP는 독립적으로 재생이 가능하며, 길이는 보통 몇 초 정도이다.
    - 어떤 종류의 오래된 단말이나 브라우저는 GOP 단위의 비디오 분할을 지원하지 않음 → 이런 경우에 전처리기가 비디오 분할을 대신함
2. `DAG 생성`
    - 클라이언트 프로그래머가 작성한 설정 파일에 따라 DAG를 만들어낸다.
        - 2개의 노드(다운로드, 트랜스코딩) 와 1개의 연결선으로 구성된 DAG는 다음과 같다.
            - [다운로드]  → [트랜스코딩]
            - 이 DAG는 2개의 설정 파일로부터 생성된 것이다.
3. `데이터 캐시` 
    - 전처리기는 분할된 비디오의 캐시이기도 함.
    - 안정성을 높이기 위해 전처리기는 GOP와 메타데이터를 `임시 저장소(temporary storage)`에 보관
    - 비디오 인코딩 실패 시 시스템은 이렇게 보관된 데이터를 활용해 인코딩 재개

### DAG 스케줄러

`DAG 스케줄러`는 DAG 그래프를 **몇 개 단계(stage)**로 분할한 다음 그 각각을 자원 관리자의 작업 큐(task queue)에 집어넣는다.

**하나의 DAG 그래프를 2개 작업 단계(stage)로 나눈 사례**

- 1단계
    - 비디오, 오디오, 메타데이터를 분리
- 2단계
    - 해당 비디오 파일을 인코딩하고 섬네일을 추출하며, 오디오 파일 또한 인코딩한다.

!https://velog.velcdn.com/images/ony/post/307e812c-0743-4c39-96a1-c0e638ef6822/image.png

### 자원 관리자

`자원 관리자(resoyrece manager)` 는 자원 배분을 효과적으로 수행하는 역할

!https://velog.velcdn.com/images/ony/post/70d6bd65-9544-41f4-b6b7-1cee2e812cfb/image.png

3개의 큐와 작업 스케줄러(task scheduler) 로 구성

- **작업 큐**
    - 실행할 작업이 보관되어 있는 우선순위 큐이다.
- **작업 서버 큐**
    - 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐이다.
- **실행 큐**
    - 현재 실행중인 작업 및 작업 서버 정보가 보관되어 있는 큐
- **작업 스케줄러**
    - 최적의 작업/서버 조합을 골라, 해당 작업 서버가 작업을 수행하도록 지시하는 역할 담당

- 작업 관리자는 **작업 큐에서 가장 높은 우선순위의 작업**을 꺼낸다.
- 작업 관리자는 해당 작업을 실행하기 **적합한 작업 서버를 고른다.**
- 작업 스케줄러는 해당 작업 서버에게 **작업 실행을 지시**한다.
- 작업 스케줄러는 해당 작업이 어떤 서버에게 할당되었는지에 관한 정보를 **실행 큐에 넣는다.**
- 작업 스케줄러는 작업이 완료되면 **해당 작업을 실행 큐에서 제거**한다.

### 작업 서버

- **`작업 서버`**는 DAG에 정의된 작업을 수행한다.
- 작업 종류에 따라 작업 서버도 구분하여 관리한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/efa7fca8-a657-41fe-a88b-fe76fba35df1/Untitled.png)

### 임시 저장소

- 임시 저장소 구현에는 여러 저장소 시스템을 활용할 수 있다.
- 어떤 시스템을 선택할 것이냐는 저장할 데이터의 유형, 크기, 이용 빈도, 데이터 유효기간 등 에 따라 달라진다.
    - ex) 메타데이터는 작업 서버가 빈번히 참조하는 정보이고 그 크기도 작은 것이 보통이다. 따라서 메모리에 캐시해두면 좋을 것이다. 그러나 비디오/오디오 데이터는 BLOB 저장소에 두는 것이 바람직하다.
- 임시 저장소에 보관한 데이터는 비디오 프로세싱이 완료되면 삭제한다.

### 인코딩된 비디오

- 인코딩된 비디오는 인코딩 파이프라인의 “최종 결과물”이다.
    - funny_720p.mp4 같은 이름을 갖는다.

## 시스템 최적화

속도, 안전성, 비용 측면에서 이 시스템을 최적화하는 방법을 알아보자

### 1-1) 속도 최적화: 비디오 병렬 업로드

- 비디오 전부를 한 번의 업로드로 올리는 것은 비효율적 → 하나의 비디오를 작은 GOP들로 분할할 수 있다.

!https://velog.velcdn.com/images/ony/post/5aaf1fd7-ee30-4fae-ba75-079ee023bae4/image.png

- 분할한 GOP를 병렬적으로 업로드하면 → 설사 일부가 실패해도 빠르게 업로드를 재개할 수 있음
- 비디오를 GOP 경계에 맞춰 분할하는 작업을 단말이 수행하면 업로드 속도를 향상시킬 수 있음

### 1-2) 속도 최적화: 업로드 센터를 사용자 근거리에 지정

업로드 센터를 여러 곳에 두고 근거리에 있는 센터로 데이터를 보낸다. 

이를 위해 CDN을 업로드 센터로 이용한다. 

### 1-3) 속도 최적화: 모든 절차를 병렬화

- 낮은 응답 지연을 위해 느슨하게 결합된 시스템을 만들어서 병렬성을 높이자

**비디오를 원본 저장소에서 CDN으로 옮기는 절차**

!https://velog.velcdn.com/images/ony/post/d0459d1f-9ea9-41a3-b827-54157feeead0/image.png

- 위의 형태를 보면 어떤 단계의 결과물은 이전 단계의 결과물을 입력으로 사용하여 만든다.
    
    → 이런 의존성이 있으면 병렬성을 높이기 어려움 - `메세지 큐`를 도입
    

- `메세지 큐`가 어떻게 시스템 결합도를 낮추는가
    - 메세지 큐를 도입하기 전 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 **기다려야 했음**
    - 메세지 큐 도입 이후 인코딩 모듈은 다운로드 모듈의 작업이 끝나기를 더 이상 기다릴 필요가 없음.
        - 메세지 큐에 보관된 이벤트 각각을 인코딩 모듈은 **병렬적으로 처리할 수 있게 됨**

**비디오를 원본 저장소에서 CDN으로 옮기는 절차 - `메세지 큐` 도입**

!https://velog.velcdn.com/images/ony/post/b09c6aef-c19d-4114-862a-9d8601483e33/image.png

### 2-1) 안정성 최적화: 미리 사인된 업로드 URL

- 허가 받은(authorized) 사용자 만이 올바른 장소에 비디오를 업로드하기 위해 미리 사인된 업로드 URL을 이용한다.

!https://velog.velcdn.com/images/ony/post/7afb4782-b651-403b-9238-2c8d75d63b43/image.png

1) 클라이언트는 HTTP 서버에 POST 요청을 하여 미리 사인된 URL을 받는다. 

해당 URL이 가리키는 객체에 대한 접근 권한이 이미 주어져 있는 상태이다. 

2) API 서버는 미리 사인된 URL을 돌려준다. 

3) 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다. 

### 2-2) 안전성 최적화: 비디오 보호

비디오 저작권을 보고하기 위해 아래의 3방안을 채택할 수 있다.

- 디지털 저작권 관리(DRM:Digital Rights Management) 시스템 도입
- AES 암호화(encryption)
    - 비디오를 암호화하고 접근 권한을 설정하는 방식
    - 암호화된 비디오는 재생 시에만 복호화.
- 워터마크(watermark)
    - 비디오 위에 소유자 정보를 포함하는 이미지 오버레이를 올리는 것

### 3-1) 비용 최적화

- CDN은 지역에 상관없이 빠르고 끊김없이 시청 가능하게 해주지만 비싸다.
- 유튜브의 비디오 스트리밍은 `롱테일(long-tail)` 분포를 따름
    - 인기 있는 비디오는 빈번히 재생되는 반면, 나머지는 거의 보는 사람이 없다. → 이를 고려하여 최적화를 시도할 수 있다.

1. 인기 비디오는 CDN을 통해 재생하되 다른 비디오는 비디오 서버를 통해 재생

!https://velog.velcdn.com/images/ony/post/2b36866b-32ae-45c6-b4bc-074ecd73767a/image.png

1. 인기가 별로 없는 비디오는 인코딩할 필요가 없을 수도 있다. 
    1. 짧은 비디오라면 필요할 때 인코딩하여 재생할 수 있다. 
2. 어떤 비디오는 특정 지역에서만 인기가 높음. 
    1. 이런 비디오는 다른 지역에 옮길 필요가 없다. 
3. CDN을 직접 구축하고 인터넷 서비스 제공자(ISP: Internet Service Provider) 와 제휴
    1. ISP는 전세계 어디나 있으며 사용자와 가깝다. 이들과 제휴하면 사용자 경험을 향상시킬 수 있고 인터넷 사용 비용을 낮출 수 있다. 

⇒ 이런 방법들을 구축하기 위해서 **시청 패턴을 분석하는 것이 매우 중요**

## 오류 처리

**시스템 오류의 종류**

- `회복 가능 오류(recoverable error)`
    - 특정 비디오 세그먼트를 트랜스코딩하다 실패했다든가 하는 오류는 회복 가능한 오류에 속함
    - 그냥 retry만 하면 해결된다.
    - 만약 계속 실패가 반복되고 복구가 어렵다면 클라이언트에게  오류코드 반환
- `회복 불가능 오류(non-recoverable error)`
    - 비디오 포맷이 잘못되었다거나 하는 회복 불가능한 오류가 발견되면 시스템은 해당 비디오에 대한 작업을 중단하고 클라이언트에게 적절한 오류 코드를 반환

**오류에 대한 전형적 해결 방법**

- 업로드 오류: 몇 번 재시도
- 비디오 분할 오류: 낡은 버전의 클라이언트가 GOP 경계에 따라 비디오를 분할하지 못하는 경우라면 전체 비디오를 서버로 전송하고 서버가 해당 비디오 분할을 처리하도록 한다.
- 트랜스코딩 오류: 재시도
- 전처리 오류: DAG 그래프를 재생성
- DAG 스케줄러 오류: 작업을 다시 스케줄링
- 자원 관리자 큐에 장애 발생: 사본(replica)을 이용
- 작업 서버 장애: 다른 서버에서 해당 작업을 재시도
- API 서버 장애: API 서버는 무상태 서버이므로 신규 요청은 다른 API 서버로 우회될 것
- 메타데이터 캐시 서버 장애: 다른 노드에서 데이터 가져오고, 장애가 난 캐시 서버는 새로운 걸로 교체
- 메타데이터 데이터베이스 서버 장애
    - 주 서버가 죽었으면 부 서버 가운데 하나를 주 서버로 교체
    - 부 서버가 죽었으면 다른 부 서버를 통해 읽기 연산을 처리하고 죽은 서버는 새 것으로 교체

# 4단계 : 마무리

- API 계층의 규모 확장성 확보 방안:
    - API 서버는 무상태 서버이므로 수평적 규모 확장이 가능하다는 사실을 언급
- 데이터베이스 계층의 규모 확장성 확보 방안:
    - 다중화, 샤딩에 대해 이야기하자
- 라이브 스트리밍(live streaming)
    - 우리가 한 건 라이브 스트리밍용 시스템은 아니다.
        - 하지만 라이브 스트리밍 시스템과 비라이브 스트리밍 시스템 간에는 비슷한 점도 많다.
        - 둘 다 비디오 업로드, 인코딩, 스트리밍이 필요하다는 점에서는 같다.
    - 차이점을 꼽자면 라이브 스트리밍의 경우에는 응답지연이 좀 더 낮아야 한다.
        - 따라서 스트리밍 프로토콜 선정에 유의해야 한다.
    - 라이브 스트리밍의 경우 병렬화 필요성은 떨어질 텐데, 작은 단위의 데이 터를 실시간으로 빨리 처리해야 하기 때문이다.
    - 라이브 스트리밍의 경우 오류 처리 방법을 달리해야 한다. 너무 많은 시간이 걸리는방안은 사용하기 어렵다.
- 비디오 삭제(takedown) 정책
    - 저작권을 위반한 비디오, 선정적인 비디오 등은 내려야 한다.

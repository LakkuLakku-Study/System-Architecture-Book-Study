# 1단계 : 문제 이해 및 설계 범위 확정

- 채팅은 유형이 다양하기 때문에 특히 요구사항을 확실히 해두는  게 좋음

### 요구사항

- 지원 기능
    - 1:1 채팅 앱 + 그룹 채팅 앱
- 지원 기기
    - 모바일 앱 + 웹 앱
- 처리해야 하는 트래픽 규모는
    - 5천만 DAU 지원
- 그룹 채팅에 인원제한이 있습니까?
    - 최대 100명
- 중요기능은 무엇인가요?
    - 텍스트만 지원
    - 사용자 접속 상태 표시
- 메시지 길이 제한
    - 100,000자
- 종단 간 암호화를 지원해야하나요?
    - 필요 없음
- 채팅이력은 얼마나 오래 보관하나요?
    - 01히~

- 우리가 설계할 채팅 요구사항
    - 응답지연이 낮은 일대일 채팅 기능
    - 최대 100명까지 가능한 그룹 채팅 기능
    - 사용자 접속상태 표시 기능
    - 다양한 단말 지원 및 한 계정 여러 단말 동시 접속 지원
    - 푸시 알림
    - 5천만 DAU 지원
    

# 2단계 : 개략적 설계안 제시 및 동의 구하기

- 채팅 서비스가 제공해야하는 기능
    - 클라이언트들로부터 메시지 수신
    - 메시지 수신자 결정 및 전달
    - 수신자가 접속 상태가 아닌 경우, 접속 시까지 해당 메시지 보관
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/a26048fe-a425-41f5-9a56-fefdc7e3fb97/Untitled.png)
    
- 채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용하여 서비스에 접속한다.
    - 이때, 어떤 프로토콜을 사용할 것인지 면접관과 상의해야한다.

- **어떤 프로토콜을 사용?**
    - 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트이다.
        - 채팅 시스템에서 메시지 송신 클라이언트가 해당 역할을 수행한다.
    - **1) HTTP 프로토콜**
        - HTTP 프로토콜을 사용하여 연결 후 송신자는 채팅 서비스에 수신자에게 메시지 전달해달라고 알린다.
            - HTTP는 웹에서 가장 널리 사용되는 프로토콜이며 오랜 세월 검증되었다.
        - 여기서는 keep-alive 헤더를 사용하면 효율적이다.
            - 클라이언트-서버 사이의 연결을 끊지 않고 계속 유지할 수 있어서이다.
            - → TCP 접속과정에서 발생하는 handshake 횟수를 줄일 수 있다.
        - 하지만 HTTP는 클라이언트가 연결을 생성하는 프로토콜
            - 서버에서 클라이언트에게 임의 시점에 메시지 전달은 어렵다.
                - (서버 💬 : 왜 너만 말해? 나도 말하고 싶다구!)
            - → 서버가 연결을 만드는 것처럼 동작할 수 있또록 많은 기법들이 제안되었음
    - **2) 폴링**
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/734d2e8a-7eec-41c8-ada0-2b70d29827e2/Untitled.png)
        
        - 클라이언트가 주기적으로 서버에게 새 메시지가 있느냐고 물어보는 방법
        - 단점 : 답해줄 메시지가 없는 경우에도 폴링을 하여 서버 자원을 낭비함
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/0fb10735-aed1-4f17-ba37-9154fdc4c69d/Untitled.png)
            
    - **3) 롱폴링**
        - 폴링의 개선하기 위해
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/cef4cb8c-4cdb-4ef3-887d-f59254df9847/Untitled.png)
        
        - 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다.
        - 클라이언트는 새 메시지를 받으면(또는 타임아웃 시) 기존 연결을 종료하고 서버에 새로운 요청을 보내 모든 절차를 다시 시작한다.
        - 약점
            - 송신자와 수신자가 같은 채팅 서버에 접속하지 않을 수 있다.
            - HTTP 서버들은 대부분 stateless 서버이므로
                - 로드 밸러싱을 위해 라운드 로빈 알고리즘을 사용하는 경우, 송신자와 수신자가 다른 채팅 서버를 사용할 수 있다.
            - 서버 입장에서 연결 해제 여부를 알 수 없다.
            - 메시지를 받지않은 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 재접속해야하므로 여전히 비효율적이다.
    - **4) 웹소켓** ✨✨✨✨✨
        - 웹 소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/e45d49ec-c999-4f45-8cd6-4b34be1a88cc/Untitled.png)
        
        - 연결은 클라이언트가 시작한다.
            - 한 번 맺어진 연결은 항구적이며 양방향이다.
        - 처음에 HTTP 연결이지만, → 특정 핸드셰이크 절차를 거쳐  → 웹 소켓 연결로 업그레이드된다.
            - 이 항구적인 연결이 만들어지고 나면 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.
                - 서버 💬 : 너만 말거냐? 나도 이제 말한다?
        - HTTP/HTTPS의 80 또는 443 포트를 그대로 사용하기 때문에 방화벽 환경에서도 동작한다.
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/62b2a79e-3663-4e24-b40f-4363e31b4bc1/Untitled.png)
            
        
        - 웹 소켓을 이용하면 송수신 때, 동일한 프로토콜을 사용할 수 있다.
            - 설계 및 구현이 단순하며 직관적이다.
        - 단, 연결이 항구적이므로 서버에서 연결 관리를 효율적으로 해야한다.
        
    

### 개략적 설계안

- 채팅할 때 통신 프로토콜로 웹소켓을 사용하기로 결정했다.
    - 하지만 다른 부분에서는 굳이 웹소켓을 쓸 필요는 없다.
        - ex) 회원가입, 로그인 등 은 일반적인 HTTP 상에서 구현해도 된다.

- 채팅 시스템은 세 부분으로 구분 가능하다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/06135aea-0af3-4dde-9bab-011f862e68ba/Untitled.png)
    
    1. stateless(무상태) 서비스
        - 로그인, 회원가입, 사용자 프로필 등 전통적인 요청/응답이 해당
        - 무상태 서비스는 로드밸런서 뒤에 위치한다.
            - 로드밸런서 뒤에는 모놀리틱 또는 마이크로서비스일 수도 있다.
        - *서비스 탐색(service discovery) 서비스는 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 알려주는 서비스이다.
    2. stateful(상태유지) 서비스
        - 본 설계에서 유일하게 상태 유지가 필요한 서비스는 채팅 서비스이다.
            - 각 클라이언트와 채팅 서버는 독립적인 네트워크 연결을 유지해야하기 때문이다.
                - 클라이언트는 서버와 연결이 살아있는 한 다른 서버로 연결을 변경하지 않는다.
        - 서비스 탐색 서비스는 채팅 서비스와 협력하여 특정 채팅 서버에 부하가 몰리지 않도록 한다.
    3. 제 3자 서비스 연동 (third-party 연동)
        - 푸시 알림이 해당된다.
        - 앱이 실행 중이 아니어도 알림을 받아야한다.
    

### 규모 확장성

- 서버 한 대로 구현하는 경우
    - 동시접속자가 1M이고, 접속당 서버 메모리가 10K가 필요하다면, 10GB의 메모리로 모든 연결을 처리할 수 있다.
    - 한 대로 다 연결을 처리할 수 있다고 해도 SPOF 문제를 갖기 때문에 서버 한 대로 설계안을 작성하면 부족한 답변이라고 할 것이다.
    - 서버 한 대 선계안에서 개선시켜나가는 방향으로 답변하는 방식은 괜찮다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/eff716ea-46ed-4ea2-a7d7-0e95b2daca0c/Untitled.png)

- 채팅서버
    - 클라이언트 사이에 메시지 중계하는 역할을 한다.
- 접속상태(presence server) 서버
    - 사용자 접속 여부를 관리한다.
- API 서버
    - 채팅을 제외한 로그인, 회원가입 프로필 변경 등 전부를 처리한다.
- 알림 서버
    - 푸시 알림을 보낸다.
- 키-값 저장소
    - 채팅 이력을 보관한다.
    - 시스템에 접속한 사용자는 이전 채팅 이력을 전부 볼 것이다.

[저장소]

- 서버 준비 완료, 제 3자 서비스 연동 완료
    - 이제 데이터 계층을 만들어보자
- 우선, 어떤 데이터베이스를 쓸 것인가?
    - 중요하게 따져아할 것은 데이터의 유형과 읽기/쓰기 연산의 패턴을 봐야한다.
    - 채팅 시스템의 데이터는 두 가지다.
        1. 사용자 프로필, 설정, 친구 목록 등 일반 데이터
            
            → 안정성을 보장하는 관계형 데이터베이스에 보관한다. 
            
            이때, 이 데이터는 다중화와 샤딩으로 데이터의 가용성과 규모 확장성을 보증할 수 있다. 
            
        2. 채팅 이력 (chat history)
            
            → 어떻게 보관할까? 읽기 쓰기 패턴을 이해해보자 
            
            - 채팅 이력 데이터는 매우 많다.
                - 페이스북 메신저나 왓츠앱은 매일 600억 개의 메시지를 처리한다.
            - 이 데이터에서 가장 자주 사용되는 것은 최근 메시지이다.
                - 대부분 사용자는 오래된 메시지를 보지않는다.
            - 사용자는 대체로 최근 메시지를 보지만, 메시지 검색 기능, 특정 사용자가 언급된 메시지 보기, 특정 메시지로 점프하기 등 무작위 데이터 접근을 지원해야한다.
            - 1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1이다.
            
            → 이 패턴을 고려했을 때 키-값 저장소가 좋다. 
            
            왜냐하면 아래를 만족하기 때문이다. 
            
            - 수평적 규모확장이 쉽다.
            - 데이터 접근 지연시간이 낮다.
            - 관계형 데이터베이스는 롱테일 long tail에 해당하는 부분을 잘 처리하지 못한다. (롱 테일에 해당하는 다양한 데이터에 대해 효율적이지 못할 수 있습니다.)
                - long tail 이란?
                    - 파레토 법칙을 그래프로 나타냈을 때 꼬리처럼 긴 부분을 형성하는 80% 부분을 말한다.
                    - 파레토 법칙은 상위 20%가 전체 80%를 차지한다는 법칙이다
                    - 대부분 사용자들의 데이터 접근은 최근 메시지에 집중되며, long tail은 오래된 메시지를 말하는 것이다.
                - 이유 : 인덱스가 커지면 데이터에 대한 무작위 접근( random access)을 처리하는 비용이 늘어난다.
            - 이미 많은 안정적인 채팅 시스템이 키-값 저장소를 사용한다.
                - 페이스북 메신저는 HBase를 사용하며 디스코드는 카산드라를 사용한다.
    
    ### 데이터 모델
    
    - 키-값 저장소에서 메시지 데이터를 어떻게 보관할 것인가?
        - 1대1 채팅을 위한 메시지 테이블
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/dcc19ad3-cf10-4daa-9301-5150ef3f370c/Untitled.png)
            
            - message_id를 기본키로 갖는다.
                - 메시지 순서를 쉽게 정할 수 있다
                - 서로 다른 두 메시지가 동시에 만들어질 수 있는 경우, created_at을 사용하여 메시지 순서를 정할 수 없기 때문에 이 경우를 고려한 것이다.
        - 그룹 채팅을 위한 메시지 테이블
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/ed6c27fa-42d5-4f3e-8696-4d14786451e4/Untitled.png)
            
            - ( channel_id, message_id ) 복합키를 기본키로 갖는다.
                - 채널 = 채팅 그룹
                - 여기서 channel_id == 파티션 키로 사용 → 그룹 채팅에 적용될 모든 질의는 특정 채널 대상으로 할 것이기 때문
    - **메시지 ID**
        - 만족해야하는 조건 2가지
            - 1) message_id는 고유해야한다.
            - 2) ID는 정렬 가능하며 시간 순서와 일치해야한다.
        - 방법 1) RDBMS의 경우는 이 조건을 만족하기 위해 auto_increment를 사용할 수 있지만 NoSQL은 지원하지 않기 때문에 snowflake와 같은 유일 ID를 사용할 수 있다.
            - 전역적 64-bit 순서 번호 생성기이다.
        
        - 방법 2) 지역적 순서 번호 생성기를 이용할 수 있다.
            - 지역적 == ID의 유일성은 같은 그룹 안에서만 보증하면 충분함
                - 메시지 사이의 순서는 같은 채널 혹은 채팅 세션 안에서만 유지하면 되기 때문이다.
            - 방법1에 비해 비교적 구현하기 쉽다.
        

# 3단계 : 상세 설계

- 서비스 탐색, 메시지 전달 흐름, 사용자 접속 상태 표시 방법 위주로 상세하게 살펴보자

## 서비스 탐색

- 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것
- 기준은 클라이언트의 위치, 서버의 용량 등이 있다.
- 대표적으로는 아파치 주키퍼가 있다.
- 사용 가능한 모든 채팅 서버를 등록하고 클라이언트가 접속 시도 시, 기준에 따라 최적의 채팅 서버를 골라주면 된다.

- 주키퍼로 구현한 서비스 탐색 기능 동작 예시
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/db66af7d-c8f0-494e-8ca0-2adafee3ee09/Untitled.png)
    
    1. A가 시스템에 로그인 시도
    2. 로드밸런서가 로그인 요청을 API 서버에 보낸다.
    3. API 서버가 사용자 인증을 처리하고 나면 서비스 탐색 기능이 동작하여 **해당 사용자를 서비스할 최적의 채팅 서버를 찾는다.** 
        1. 채팅 서버 2가 선택되어 사용자 A에게 반환되었다고 하자 
    4. 사용자 A는 채팅 서버 2와 웹소켓 연결을 맺는다. 
    

> 주키퍼란?
> 
> 
> ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/73eed6ce-5d37-43b4-afcc-ae277ce63785/Untitled.png)
> 

```
ZooKeeper는 n개의 서버로 단일 주키퍼 클러스터를 구성하며 이를 서버 앙상블이라고 한다. 클라이언트는 앙상블에 속한 서버에 연결하여 서비스를 사용할 수 있다. 다음은 주키퍼 아키텍처이다.

- zookeeper 서비스는 복수의 서버에 복제되며, 모든 서버는 데이터 카피본을 저장하고 있다
	Zookeeper Atomic Broadcast (Zab) 프로토콜을 사용하여 데이터 변경 사항을 모든 서버에 복제합니다. 리더 서버는 클라이언트의 쓰기 요청을 받아 데이터를 변경하고, 이 변경 사항을 모든 팔로워 서버에 전파합니다.
	리더가 변경 사항을 모든 팔로워에게 브로드캐스트하고, 과반수의 팔로워로부터 승인을 받아야 변경이 완료됩니다. 과반수가 합의하면 변경이 확정되고, 모든 서버는 데이터를 동일하게 유지합니다.
	
	
- 리더는 구동 시 zookeeper 내부 알고리즘에 의해 자동 선정된다
- Followers 서버들은 클라이언트로부터 받은 모든 업데이트 이벤트를 리더에게 전달한다.
- 클라이언트는 모든 주키퍼 서버에서 읽을 수 있으며, 리더를 통해 쓸 수 있고 과반수 서버의 승인(합의)가 필요하다.
```

## 메시지 전달 흐름

### 1:1 채팅 메시지 처리 흐름

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/f890f37f-ca34-4c4a-aa68-35ada4b8ded1/Untitled.png)

1. 사용자 A가 채팅 서버 1로 메시지 전송
2. 채팅 서버 1은 ID 생성기로 message_id 결정
3. 채팅 서버 1은 해당 메시지를 **메시지 동기화 큐**로 전송
4. 메시지를 키-값 저장소에 저장
5. (a) 사용자 B(상대방)가 접속 중(온라인)인 경우, 메시지는 B가 접속 중인 채팅 서버 2로 전송됨.
    
    (b) 사용자 B(상대방)가 접속 중이 아니라면(오프라인), 푸시 알림 메시지를 푸시 알림 서버로 보냄 
    
6. 채팅 서버 2는 메시지를 사용자 B에게 전송
    1. 사용자와 B와 채팅 서버 2사이에는 웹소켓 연결이 있는 상태이므로 그것을 이용

### 여러 단말 사이의 메시지 동기화

- 여러 단말을 사용하는 사람은 많다.
    - ex) 디스코드를 노트북으로 접속하고 동시에 핸드폰으로도 접속했을 때
- 접속 상황
    - 사용자 A가 전화기에서 채팅 앱에 로그인한 결과로 채팅 서버 1과 해당 단말 사이에 웹소켓 연결이 만들어져있다.
    - 동시에 랩톱에서 로그인한 결과로 역시 별도 웹소켓이 채팅 서버 1에 연결되어 있는 상황이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/20688a25-0d4e-48f0-a38f-eda0bb8298c0/Untitled.png)

- 각 단말은 가장 최신 메시지의 ID를 추적하는 용도인  cur_max_message_id 변수를 갖는다.
    - 아래 두 조건을 만족한 경우 새 메시지로 간주한다.
        - 수신자 ID가 현재 로그인한 사용자 ID와 같은 경우
        - message_id가 cur_max_message_id보다 큰 경우
- cur_max_message_id 는 각 단말마다 별도로 유지 관리하면 되는 값이라 키-값 저장소에서 새 메시지를 가져오는 동기화 작업도 쉽게 구현할 수 있다.

- 시나리오
    - 새로운 메시지 수신이 발생하여 채팅 서버는 새로운 메시지 ID 843을 KV 저장소에 저장합니다.
    - 이때, 각 단말의 동작은 아래와 같다.
        - User A의 Phone:
            - 서버와의 연결을 통해 최신 메시지를 확인합니다.
            - 메시지 ID 843이 cur_max_message_id (653)보다 크므로 새 메시지로 간주됩니다.
            - 새로운 메시지를 가져와 화면에 표시하고, cur_max_message_id를 843으로 업데이트합니다
        - User A의 Laptop:
            - 이미 cur_max_message_id (842)를 유지하고 있습니다.
            - 메시지 ID 843이 cur_max_message_id보다 크므로 새 메시지로 간주됩니다.
            - 새로운 메시지를 가져와 화면에 표시하고, cur_max_message_id를 843으로 업데이트합니다.
    - 결과
        - 두 단말 모두 메시지 ID 843을 수신하여 화면에 최신 메시지를 표시합니다.
        - 각 단말의 cur_max_message_id는 843으로 업데이트되어 다음 메시지를 기다립니다.
        - 즉, 각 단말은 자신의 cur_max_message_id를 기준으로 새 메시지를 식별하고, 이를 통해 여러 기기 간에 일관된 메시지 동기화를 유지합니다.
            - 이 부분이 이해가 잘 안되었다. 핸드폰에서 새로운 메시지를 읽었으면 노트북으로 다시 접속해보면 읽음처리되어있지 않은가? 하지만 그런 부분이 아니라 노트북 입장에선 그 새로운 메시지를 가져와야하기 때문에 같은 계정이라도 각 단말마다 어디까지 최신 메시지인지 알아야 내용을 전부 가져올 수 있다.
                - ex) 메시지 2~ 메시지 4를 핸드폰에서 확인하고 이후 노트북을 키면 이미 읽어서 안가져오는 것이 아니라 노트북 기준으로는 메시지 1이 최신이므로 메시지 1~4를 가져와야할 것이다.
        
    

### 소규모 그룹 채팅에서의 메시지 흐름

- 1:1 채팅에 비해 그룹 채팅은 조금 더 복잡하다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/b41373d0-1857-4325-a990-b7c0c09383c2/Untitled.png)

- 상황
    - 3명의 그룹 채팅 방에 사용자 A가 그룹 채팅 방에서 메시지를 보냈을 때 어떤 일이 벌어지는지
- 방법
    - 사용자 A가 보낸 메시지가 사용자 B와 C의 메시지 동기화 큐에 복사된다.
        - 이 큐를 사용자 각각에 할당된 메시지 수신함 같은 것으로 생각해도 무방(집집마다 우체통이 있는 느낌)
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/e61ec5d3-c98c-4389-b891-5d096458c0a6/Untitled.png)
            
        - 이 설계안이 소규모 그룹 채팅에 적합한 이유
            - (1) 새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 된다.
                - → 메시지 동기화 플로가 단순하다.
            - (2) 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업 비용이 문제가 되지 않는다.
    - 위챗이 이런 접근법 사용, 크기는 500명 제한 (이 인원 수보다 많으면 모든 사용자의 큐에 복사하는 것은 바람직하지 않을 것이다)

## 접속 상태 표시

- 접속상태 표시는 채팅 애플리케이션의 핵심 기능
    - ex) 사용자 프로필 옆에 나타나는 녹색 불
- 접속 상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스 중 하나이다.

- (1) 사용자 로그인
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/7819c080-cd3e-4d86-901c-6c8dcdd5e498/Untitled.png)
    
    - 1) 클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면
    - 2) 접속 상태 서버는 A의 상태와 last_active_at 타임 스탬프 값을 키-값 저장소에 보관한다.
    - 3) 이 절차 끝나고 해당 사용자는 접속 중인 것으로 표시
- (2) 로그아웃
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/c419ebca-3380-4201-b43a-5f166a0a122a/Untitled.png)
    
    - 1) 키-값 저장소에 보관된 사용자 상태가 online에서 offline으로 바뀌게 된다.
    - 2) 이 절차가 끝나면 UI상에서 접속중이 아닌 것으로 표시 된다.

- (3) 접속 장애
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/69ac033b-934f-488f-9f22-6788448baf33/Untitled.png)
    
- 만약 인터넷을 통한 연결이 안정적이지 않은 경우 이에 대응할 수 있는 설계가 필요하다
    - 인터넷 연결이 끊어지면 → 클라이언트와 서버 사이에 맺어진 웹소켓 같은 지속성 연결도 끊어진다.
- 이런 장애에 대응하는 간단한 방법
    - 방법 1) 사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 변경하기
        - 하지만 자주 인터넷이 끊기는 상황 발생시 (터널 지나기) 사용자 경험 측면에서 계속 접속 상태를 변경하니까 좋지 않다.
    - 방법 2) 박동(heartbeat) 검사를 통해 이 문제를 해결한다.
        - 온라인 상태의 클라이언트가 주기적으로 박동 이벤트를 접속 상태 서버로 보내고
        - 마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 해당 사용자의 접속 상태를 계속 온라인으로 유지하는 것이다.
            - 이렇지 않을 경우 오프라인임
        - 예시
            - 박동 이벤트를 5초마다 서버로 보내고 있다.
            - 그런데 이벤트를 3번 보낸 후 x = 30초 동안 아무런 메시지를 보내지 않아 오프라인 상태로 변경함
    
- (4) 상태 정보의 전송
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/d79c2dc5-cbf1-4df4-ac67-3f0b713ff3ca/Untitled.png)
    
    - 사용자A와 친구 관계에 있는 사용자들은 어떻게 해당 사용자의 상태 변화를 알게 될까?
    - **상태 정보 서버는 발행 -구독 모델을 사용**
        - 각각의 친구 관계마다 채널을 하나씩 두는 것
        - ex) 사용자 A의 접속 상태가 변경되었다고 하자
            - 1) 그 사실을 A와 관계가 있는 3개 채널== A-B, A-C, A-D 사이의 채널에 쓴다.
                - 이때, 각각 3개의 채널은 아래와 같다.
                    - A-B ⇒ 사용자 B가 구독하고
                    - A-C ⇒ 사용자 C가 구독
                    - A-D ⇒ 사용자 D가 구독한다.
            - 2) 이렇게 하면 친구 관계에 있는 사용자가 상태정보 변화를 쉽게 통지 받을 수 있게 된다.
            - 이때, 클라이언트와 서버 사이의 통신에는 실시간 웹소켓을 사용한다.
    - **그룹 크기에 따른 적합성이 달라진다.**
        - 그룹이 작을 때 이 방법은 효과적
        - 하지만 그룹이 커지면 접속상태 변화를 그룹에 있는 모든 사람, 즉 모든 채널에 알리는 방법은 비용과 시간이 많이 들게 된다.
            - 따라서, 사용자가 그룹 채팅에 입장하는 순간에만 상태정보를 읽거나 사용자가 친구의 접속상태를 수동으로 갱신하는 방식을 사용할 수 있다.
    

# 4단계 : 마무리

- 논의하면 좋은 것들
    - 미디어 파일을 지원하는 방법
        - 미디어 파일은 용량이 크다 →  압축, 클라우드 저장소, 섬네일 생성 등을 논의할 수 있다.
    - 종단 간 암호화
        - 발신인과 수신인 외에 아무도 볼 수 없게 하는 것
    - 캐시
        - 이미 읽은 메시지를 캐시하면 서버와 주고받는 데이터를 줄일 수 있다.
    - 로딩 속도 개선
        - 슬랙은 사용자 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선했다.
    - 오류 처리
        - 채팅 서버 오류
            - 채팅 서버가 죽으면 서비스 탐색 서비스가 클라이언트에게 새로운 서버를 배정하고 재접속 할 수 있도록 해야한다.
            - 주키퍼가 동작하여 클라이언트에게 새로운 서버를 배정하고 다시 접속할 수 있도록 한다.
        - 메시지 재전송
            - 재시도나 큐는 메시지의 안정적 전송을 보장하는 일반적인 기법이다.
            

이미지 출처 : [https://velog.io/@ohdowon064/가상-면접-사례로-배우는-대규모-시스템-설계-기초.-챕터-12.-채팅-시스템-설계](https://velog.io/@ohdowon064/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88.-%EC%B1%95%ED%84%B0-12.-%EC%B1%84%ED%8C%85-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84)

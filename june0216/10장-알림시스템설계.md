- 알림 기능은 중요한 정보를 “비동기적”으로 제공한다.
- 알림 시스템의 분류 3가지
    - 1) 모바일 푸시 알림
    - 2) SMS 메시지
    - 3) 이메일

# 1단계 문제 이해 및 설계 범위 확정

아래의 질문을 통해 요구사항을 구체적으로 알아내자 

- 어떤 종류의 알림?
    - ex) 푸시 알림, SMS 메시지, 이메일이다.
- 실시간 시스템(real-time)이어야 하나요?
    - ex) 실시간 시스템 중 연성(soft real-time) 실시간 시스템이라고 가정, 알림은 가능한 빨리 전달되어야 하지만 시스템에 높은 부하가 걸렸을 때 약간의 지연까지 괜찮다.
    - *제약에 엄격함에 따라 연성과 경성으로 나눌 수 있음
- 어떤 종류의 단말을 지원해야 하나요?
    - ex) iOS, 안드로이드, 그리고 랩톱, 데스크톱을 지원
- 사용자에게 보낼 알림은 누가 만들 수 있나요?
    - ex) 클라이언트 애플리케이션 프로그램 혹은 서버측에서 스케줄링
- 사용자가 알림을 받지 않도록(opt-out) 설정할 수도 있어야 하나요?
    - ex) yes
- 하루에 몇 건의 알림을 보낼 수 있어야 하나요?
    - ex) 모바일 푸시 알림 → 천만 건
    - SMS 메시지 → 백만 건
    - 이메일 → 오백만 건

# 2단계 개략적 설계안 제시 및 동의 구하기

- 알림 시스템의 개략적인 설계안을 살펴보자
    - 알림 유형별 지원 방안
    - 연락처 정보 수집 절차
    - 알림 전송 및 수신 절차

## 알림 유형별 지원 방안

### 알림 매커니즘

1) iOS 푸시 알림 

- 3가지 컴포넌트 필요
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/5b95c077-c98f-4962-87a2-989eacef1b5e/Untitled.png)
    
    - (1) 알림 제공자
        - → 알림 요청을 만들어 애플 푸시 알림 서비스(APNS)로 보내준다.
        - 이때, “단말 토큰(고유 식별자)”과 “페이로드(알림 내용, JSON)” 데이터가 필요
            
            ```json
            [페이로드 예시]
            
            {
              "aps" : {
            		  "alert" : {
            				  "title" : "Game Request", 
            				  "body" : "Bobs wants to play chess", 
            				  "actions-loc-key" : "PLAY"
            				  }, 
            				  "badge" : 5
            	   }
            	}
            				  
            ```
            
    - (2) APNS(Apple Push Notification Service)
        - → 애플이 제공하는 원격 서비스
        - iOS 장치로 보내는 역할
    - (3) iOS 단말
        - → 푸시 알림을 수신하는 사용자 단말
    

2) 안드로이드 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/e8e6e18f-4f31-4db6-a9de-ba6914299fcd/Untitled.png)

- FCM(Firbase Cloud Messaging) 사용하여 단말에 보낸다.

3) SMS 메시지 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/b7e4980e-4931-40b9-babd-9294c78a717e/Untitled.png)

- SMS 메시지는 제3 사업자의 서비스를 많이 이용한다.
    - 대부분이 상용 서비스라 이용 요금을 내야한다. 💸
    - ex) 트윌리오, 넥스모
        - Twilio Inc.는 캘리포니아 주 샌프란시스코에 본사를 둔 미국 클라우드 통신 회사로, 웹 서비스 API를 사용하여 전화 통화, 문자 메시지 전송 및 수신, 기타 통신 기능 수행을 위한 프로그래밍 가능한 통신 도구를 제공
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/5da6ce16-87b9-4aae-bb80-c9dd7138cd76/Untitled.png)
            

4) 이메일

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/441f07b2-da29-46a7-9dfc-04bf4ddf17ca/Untitled.png)

- 대부분은 회사 이메일 고유 서버를 갖추고 있음
- 하지만 그럼에도 상용 이메일 서비스를 이용함 → 전송 성공률이 높고 데이터 분석 서비스도 제공함
    - ex) 샌드그리드, 메일침프
        
        > 대부분의 서버 및 호스팅 회사의 자체 메일 서버의 경우 이메일 전송에 대한 제한이 걸려있습니다. 보통 서비스 내역에 Limits for the SMTP relay 또는 Sending Limit으로 표기가 되는데, 실제 sendmail을 통해 메일 전송 자체를 네트워크 단에서 차단하기 때문에 하루에 전송량이 제한되어 있습니다. 또는 해당 서버나 호스팅 서버의 IP가 블랙리스트로 등록이 되어 있다면, 이 제한 설정이 없더라도 서버를 통해 발송되는 대부분의 메일이 수신 거부되거나 스팸메일로 들어가게 됩니다.
        > 
        > 
        > 오픈마케팅랩은 Sendgrid의 SMTP 또는 API를 통해 **스팸메일함이 아닌 인박스로 정확하게 이메일 전송이 가능**하도록 고객의 서비스와 Sendgrid 서비스를 Integrate 해드립니다.
        > 

- 알림 유형을 하나의 시스템으로 묶으면 다음과 같음
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/6474cddf-e96b-448a-9e89-b0b677c7b19a/Untitled.png)
    

## 연락처 정보 수집 절차

- 알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요함
    - 계정을 처음 등록할 때 사용자의 정보를 데이터베이스에 저장한다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/893c35ca-2c7a-4263-970d-1082be429c7b/Untitled.png)
    
    - user 테이블 → 이메일, 전화번호 등
    - device 테이블 → 단말 토큰
    

### 알림 전송 및 수신 절차

[대략적인 설계안]

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/54cb2fe9-36f5-4d2d-a0ec-d50aeed15d6f/Untitled.png)

- **1부터 N까지의 서비스**
    - 이 서비스 각각은 마이크로 서비스일 수 있고, 크론잡(cronjob)일 수 있고, 분산 시스템 컴포넌트일 수도 있다.
        - ex) 사용자에게 납기일을 알리고자 하는 과금 서비스, 배송 알림을 보내려는 쇼핑몰 웹사이트 등
- **알림 시스템**
    - 알림 시스템은 알림 전송/수신 처리의 핵심이다.
    - 이 시스템은 서비스 1-N에 알림 전송을 위한 API를 제공해야 하고, 제3자 서비스에 전달할 알림 페이로드(payload)를 만들어 낼 수 있어야 한다.
- **제3자 서비스**
    - 사용자에게 알림을 실제로 전달하는 역할을 한다
    - 제3자 서비스와의 통합을 진행할 때 유의할 것은 **확장성**이다. == 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다.
    - 어떤 서비스는 다른 시장에서 사용할 수 없을 수도 있다는 것을 고려해야 한다.
- **ios, 안드로이드, SMS, 이메일 단말**
    - 사용자는 자기 단말에서 알림을 수신한다.

[문제점]

- SPOF(Single-Poing-Of-Failure)
    - 알림 서비스 서버가 하나 밖에 없어, 그 서버에 장애가 생기면 전체 서비스의 장애로 이어진다.
- 규모 확장성
    - 한 대 서비스로 푸시 알림에 관계된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.
- 성능 병목
    - 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업일 수 있다.
        - ex) HTML 페이지를 만들고 제3자 서비스의 응답을 기다리는 일은 시간이 많이 걸릴 가능성이 있는 일이다.
            - 사례 : 온라인 쇼핑몰 주문 알림 시스템
                - 주문이 완료되면, 서버는 사용자에게 주문 확인 페이지를 보여주기 위해 HTML 페이지를 생성합니다. 이 페이지는 주문 상세 정보, 결제 상태, 배송 예정 정보 등을 포함할 수 있습니다.
                - 쇼핑몰 서버는 제3자 결제 서비스로부터 결제가 성공적으로 처리되었는지에 대한 응답을 기다립니다. 이 때 네트워크 지연, 결제 서비스의 처리 시간 등으로 인해 시간이 지연될 수 있습니다.
                - 결제 확인 응답을 받은 후, 쇼핑몰은 이 정보를 기반으로 사용자에게 주문 확인 이메일이나 SMS 알림을 전송합니다. 이 과정에서도 메일 서버로의 요청, SMS 게이트웨이와의 상호작용이 포함되어 추가적인 시간이 소요될 수 있습니다.
    - → 모든 것을 한 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템이 과부하 상태에 빠질 수 있다.
    

[개선된 설계안]

- **데이터베이스와 캐시**를 알림 시스템의 주 서버에서 분리된다.
- **알림 서버를 증설**하고 자동으로 **수평적 규모 확장**이 이루어질 수 있도록 한다.
- **메시지 큐를** 이용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/e815852b-c408-4290-937d-5d8b1108ef6c/Untitled.png)

- **1부터 N까지의 서비스**
    - 알림 시스템 서버의 API를 통해 알림을 보낼 서비스들
- **알림 서버:** 다음과 같은 기능 제공
    - **알림 전송 API**: 스팸 방지를 위해 보통 사내 서비스 or 인증된 클라이언트만 사용가능
    - **알림 검증**: 이메일 주소, 전화번호, 등에 대한 기본적 검증을 수행
    - **데이터베이스 or 캐시 질의**: 알림에 포함시킬 데이터를 가져오는 기능
    - **알림 전송**: 알림 데이터를 메시지 큐에 넣는다. 하나 이상의 메시지 큐를 사용할 경우 알림을 병렬적으로 보낼 수 있다.
    - api 예시  (SMS 전송 기능)
        
        ```json
        
        POST https://api.example.com/v/sms/send
        {
        		"to" : [. #도착 -> 객체로 묶음 -> 여러 명한테 보낼 수 있음 
        				{
        						"user_id" : 123 #user_id 123인 사용자에게 메시지를 보냄
        				}
        		],
        		
        		"from" : { # 메시지를 보내는 사람의 정보
        					"email" : "from_address@gmail.com"
        			},
        			
        			"subject" : "Hello", #메시지의 제목
        			
        			"content" : [. #내용
        					{
        							"type" : "text/plain", #내용의 형식을 지정 -> 일반 텍스트 형식이라는 의미
        							"value" : "Hello" # "Hello"라는 텍스트를 담고 있음
        					}
        			]
        	}
        ```
        
- **캐시**
    - 주로 자주 조회되지만 자주 변경되지 않는 데이터, 예를 들어 사용자 정보, 단말 정보, 알림 템플릿 등을 저장하는 데 사용
    - → 데이터베이스의 부하를 줄이고 응답 시간을 단축
    - 일반적으로 redis 사용
- **데이터베이스**
    - 알림 서비스의 핵심 데이터를 관리  → 사용자, 알림, 설정 등 다양한 정보를 저장
    - 캐시에 저장할 데이터의 원본 역할을 함
- **메시지 큐**
    - 시스템 컴포넌트 간 **의존성을 제거**하기 위해 사용한다.
    - 다량의 알림이 전송되어야 하는 경우를 대비한 버퍼 역할도 한다.
    - **알림의 종류별**로 별도의 메시지 큐를 사용했는데, 이에 따라 제3자 서비스 가운데 하나에 장애가 생겨도 다른 종류의 알림은 정상 작동한다.
    - 일반적으로 아래의 스택을 사용한다
        - **RabbitMQ**: 고급 메시지 큐 프로토콜(AMQP)을 지원하는 메시지 브로커로, 복잡한 라우팅과 메시지 관리를 지원합니다.
        - **Apache Kafka**: 고성능, 확장 가능한 메시지 시스템으로 대량의 데이터를 처리하는데 적합하며, 실시간 스트리밍 처리에 자주 사용됩니다.
- **작업 서버**
    - 메시지 큐에서 전송할 알림을 꺼내서 제3자 서비스로 전달하는 역할을 담당하는 서버다.
    - 알림 전송 실패 시 재시도 로직을 수행할 수 있습니다.
    - 보통
        - **Node.js**: 비동기 이벤트 처리에 강점을 가지며, 실시간 데이터 처리에 적합합니다. 작업 서버로 많이 사용한다.
        - 스프링 자체가 메시지 큐에서 메시지를 가져와 처리할 수 있는 강력한 기능과 라이브러리를 제공하기 때문에, 스프링을 사용하여 작업 서버의 역할도 수행할 수 있습니다.
            - Spring Integration과 Spring Cloud Stream: 이들은 메시지 기반의 애플리케이션을 쉽게 구축할 수 있도록 도와주는 라이브러리입니다. Spring Integration은 엔터프라이즈 통합 패턴을 제공하며, Spring Cloud Stream은 메시지 브로커와의 연동을 추상화하여 더 쉬운 메시지 스트리밍을 가능하게 합니다.
- **제3자 서비스**
    - 사용자에게 알림을 실제로 전달하는 역할을 한다
    - 제3자 서비스와의 통합을 진행할 때 유의할 것은 **확장성**이다.
    - 어떤 서비스는 다른 시장에서 사용할 수 없을 수도 있다는 것을 고려해야 한다.
- **ios, 안드로이드, SMS, 이메일 단말**
    - 사용자는 자기 단말에서 알림 수신
    

[어떻게 알림이 발송되는가?]

1. API를 호출하여 알림 서버로 알림을 보낸다.
2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.
3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위한 큐에 넣는다.
4. 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.
5. 작업 서버는 알림을 제3자 서비스로 보낸다.
6. 제3자 서비스는 사용자 단말로 알림을 전송한다.

# 3단계 상세 설계

- 아래의 내용을 살펴보자
    - 안정성
    - 추가로 필요한 컴포넌트 및 고려사항
        - 알림 템플릿, 알림 설정, 전송률 제한(rate limiting), 재시도 매커니즘(retry mechanism), 보안, 큐에 보관된 알림에 대한 모니터링과 이벤트 추적
    - 개선된 설계안

### 1) 안정성

- 분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위한 사항 몇 가지를 반드시 고려해야 한다.
- **1) 데이터 손실 방지** ⭐⭐⭐⭐
    - 가장 중요한 요구사항 중 하나 → 알림이 소실되면 안 된다.
        - 지연되거나 순서가 틀려도 되지만 사라지만 곤란함 ㅜㅜ
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/e4373dfe-9e78-4fc1-8b25-3715e7decd97/Untitled.png)
            
        - ⇒ 알림 시스템은 알림 데이터를 데이터베이스에 보관하고  “재시도 매커니즘”을 구현해야한다.
            - 방법 = 알림 로그 데이터베이스를 유지한다.
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/fd5b3114-55ae-42ff-b3cd-d9321d3df342/Untitled.png)
            
            - 예시
                - 알림 로그 데이터베이스에 각 알림의 전송 시도, 상태, 결과 및 재시도 정보를 기록
                    
                    ```json
                    MessageID: 각 메시지에 고유 ID를 부여합니다.
                    
                    UserID: 메시지를 받는 사용자의 ID.
                    
                    MessageType: SMS, 이메일, 앱 푸시 등 메시지 유형.
                    
                    Status: 메시지 전송 상태 (Pending, Sent, Failed 등).
                    
                    Timestamp: 메시지 전송 시도 시각.
                    
                    RetryCount: 메시지 재시도 횟수.
                    
                    LastError: 마지막 전송 실패 원인.
                    ```
                    
                - 1) 초기 전송 시도: 알림을 전송하고 결과를 데이터베이스에 기록합니다. 성공 시 Sent, 실패 시 Failed 상태를 저장.
                - 2) 재시도 스케줄링: Failed 상태의 메시지는 일정 시간 후 재시도합니다. 이는 크론 작업, 또는 백그라운드 작업 스케줄러를 통해 구현할 수 있습니다.
                - 3) 재시도 제한: RetryCount를 통해 재시도 횟수를 제한합니다. 일반적으로 3~5회가 일반적입니다.
                - 4) 상태 업데이트: 각 시도 후 메시지 상태를 업데이트합니다. 모든 재시도가 실패하면 최종 상태를 Failed로 설정하고 종료합니다.
    - **2) 알림 중복 방지**
        - 중복 전송을 100% 방지하는 것이 불가능!
            - 전달 의미 체계 유형인 '최대 한 번(at-most-once)', '최소 한 번(at-least-once)', '정확히 한 번'의 세 가지 전달 방식 중에서 '최대 한 번'과 '최소 한 번'이 실제로 사용 가능하고 널리 적용되고 있습니다.
            - 왜냐하면 분산 시스템은 항상 트레이드오프를 필요로 한다고 설명합니다. 특히, 네트워크 분할이나 시스템의 크래시와 같은 상황에서 메시지를 신뢰성 있고 순서대로 전달하는 것은 매우 어렵습니다. 이러한 문제를 해결하기 위해 많은 조정과 자원이 필요
            - 상태 변경은 멱등성이 있으며 애플리케이션 순서가 전달 순서와 일치하는 한 동일한 상태 변경을 여러 번 적용해도 불일치가 발생하지 않습니다. 결과적으로, 적어도 한 번 의미 체계를 보장하는 것만으로도 충분하며 구현이 단순화됩니다.
            - *확인을 사용할 때 채널 또는 연결 실패에서 복구하는 생산자는 브로커로부터 승인을 받지 못한 모든 메시지를 다시 전송해야 합니다. 네트워크 장애 등으로 인해 브로커가 생산자에게 도달하지 못한 확인 메시지를 보냈을 수 있으므로 여기에 메시지가 중복될 가능성이 있습니다. 따라서 소비자 애플리케이션은 중복 제거를 수행하거나 멱등성 방식으로 수신 메시지를 처리해야 합니다.*
        - 이에 따라 분산 시스템의 경우 가끔은 같은 알림이 중복되어 전송되기도 할 것이다.
        - 아예 중복을 없애는 방법은 불가능하고 그 “빈도”를 줄이려면 중복을 탐지하는 매커니즘을 도입하고 오류를 신중하게 처리해야한다.
        - 간단한 중복 방지 로직 사례
            - 보내야 할 알림이 도착하면 그 이벤트 ID를 검사하여 이전에 본 적이 있는 이벤트인지 살핀다. 중복된 이벤트라면 버리고, 그렇지 않다면 알림을 발송한다.
        
        ### 2) 추가로 필요한 컴포넌트 및 고려사항
        
        알림 시스템은 생각보다 훨씬 복잡한 기능이다.
        
        지금부터 알림 템플릿, 알림 설정, 이벤트 추적, 시스템 모니터링, 처리율 제한 등 알림 시스템 구현을 위해 필요한 추가 컴포넌트들에 대해 알아보자.
        
        - **1) 알림 템플릿**
            - 대형 알림 시스템은 수많은 알림을 처리한다. 하지만 그 알림들 대부분은 형식이 비슷하다.
            - 따라서 알림 메시지의 모든 부분을 처음부터 다시 만들 필요 없도록 해준다.
            - 알림 템플릿은 인자(parameter)나 스타일, 추적 링크를 조정하기만 하면 사전에 지정한 형식에 맞춰 알람을 만들어 내는 틀이다.
                - ex) 안녕하세요 {user_name}! {item_name}이 재입고 되었습니다!
        - **2) 알림 설정**
            - 많은 웹 사이트와 앱에서는 사용자가 알림 설정을 상세히 조정할 수 있도록 하고 있다.
                - 알림을 보내기 전에 반드시 해당 설정을 확인하도록 시스템 설계
            - 이 정보는 알림 설정 테이블에 보관되며, 이 테이블에는 다음과 같은 필드들이 필요할 것이다.
                
                
                | user_id | bigint |  |
                | --- | --- | --- |
                | channel | varchar | # 알림이 전송될 채널, 푸시 알림, 이메일, SMS 등등 |
                | opt_in | boolean | # 해당 채널로 알림을 받을 것인지 여부 |
        
        - **3) 전송률 제한**
            - 사용자에게 너무 많은 알림을 보내지 않도록 하는 한 가지 방법은 **한 사용자가 받을 수 있는 알림의 빈도를 제한하는 것이다.**
                
                → 알림을 너무 많이 보내면 알림 기능을 꺼버릴 가능성이 있기 때문
                
        - **4) 재시도 방법**
            - 제3자 서비스가 알림 전송에 실패하면, 해당 알림을 재시도 전용 큐에 넣는다.
            - 같은 문제가 계속해서 발생하면 개발자에게 통지한다(alert)
                
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/5ac84df9-db21-4b35-8d83-8b8043dbbf0c/Untitled.png)
                
        - **5) 푸시 알림과 보안**
            - iOS와 안드로이드 앱의 경우, 알림 전송 API는 appKey, appSecret을 사용하여 보안을 유지한다.
            - 따라서 인증된(authenticated), 혹은 승인된(verified) 클라이언트만 해당 API를 사용하여 알림을 보낼 수 있다.
        - **6) 큐 모니터링**
            - 알림 시스템을 모니터링할 때 중요한 메트릭 하나는 “큐에 쌓인 알림의 개수”이다.
            - 이 수가 너무 크면 → 작업들이 빠르게 처리하고 있지 않다는 것이다.
                - → 서버를 증설해야한다.
        - **7) 이벤트 추적**
            - 알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 같은 메트릭은 사용자를 이해하는 데 중요
            - 데이터 분석 서비스는 보통 이벤트 추적 기능도 제공하기 때문에 보통 알림 시스템을 만들면 데이터 분석 서비스와도 통합
            - 데이터 분석 서비스를 통해 추적하게 될 알림 시스템 이벤트의 사례
                
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/7b8ceefc-f87d-4ffd-91c2-ca926817bd79/Untitled.png)
                

### 수정된 설계안

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/73be48a7-1669-4f6c-8b27-ec7f9566489f/Untitled.png)

- 알림 서버에 “인증”과 “전송률 제한 기능”이 추가
    - 인증된 클라이언트만이 알림을 보낼 수 있도록 appKey, appSecret 등 매커니즘을 이용하였다.
    - 사용자에게 알림을 보내는 빈도를 제한한다.
- 전송 실패에 대응하기 위한 재시도 기능이 추가되었다.
    - 전송에 실패한 알림은 다시 큐에 넣고 지정된 횟수만큼 재시도한다.
- 전송 템플릿을 사용하여 알림 생성 과정을 단순화하고 알림 내용의 일관성을 유지한다.
- 모니터링과 추적 시스템을 추가하여 시스템 상태를 확인하고 추후 시스템을 개선하기 쉽도록 하였다.

# 4단계 마무리

- 알림은 중요 정보를 계속 알려준다는 점에서 필요 불가결한 기능
- 다양하게 알림을 제공하는 방법과 시스템 컴포넌트 사이의 결합도를 낮추기 위해 메시지 큐를 적극적으로 사용했다.
- 특히, 안정성, 보안, 이벤트 추적 및 모니터링, 사용자 설정, 전송률 제한에 집중하여 설계해보았다

# 뉴스 피드

- 지속적으로 업데이트되는 스토리들
- 사용자의 상태 정보 업데이트, 사진, 비디오, 링크, 앱 활동
- 아주 유명한 면접 문제
    - ex) 페이스북 뉴스 피드 설계, 인스타글매 피드 설계, 트위터 타임라임 설계

# 4단계 접근법

# **1단계 문제 이해 및 설계 범위 확정**

### 요구사항

- 중요 기능
    - 사용자는 뉴스 피드 페이지에 새로운 스토리를 올릴 수고, 친구들이 올린 스토리를 볼 수 있어야 한다.
- 정렬 기준
    - 시간 흐름 역순으로 스토리가 표시되어야 한다.
- 팔로워 최대 수
    - 한 명의 사용자는 최대 5000명의 팔로워를 가질 수 있다.
- 트래픽 규모
    - 하루에 천만명이 방문할 수 있다.
- 피드의 컨텐츠 종류
    - 피드에는 이미지나 비디오 등의 미디어 파일이 포함될 수 있다.

# 2단계 : 개략적 설계안 제시 및 동의 구하기

**피드 발행**과 **뉴스 피드 생성**으로 나누어서 생각하자.

- 피드 발행
    - 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록한다.
    - 새 포스팅은 친구의 뉴스 피드에도 전송된다.
- 뉴스 피드 생성
    - 모든 친구의 포스팅을 **시간 흐름의 역순**으로 모아서 만든다.

## 뉴스 피드 API

- 클라이언트가 서버와 통신하기 위해 사용하는 수단
- HTTP 프로토콜 기반
- 여러 기능들이 있지만 가장 중요한 2가지 API인 피드 발행 API 와 피드 읽기 API를 살펴보자

### 피드 발생 API

- 새 스토리를 포스팅하기 위한 API
- POST `/v1/me/feed` 으로 요청
    - body: 포스팅 내용
    - Authorization header: API 호출 인증 값
        - 여기서 의문점이 생겼다.
            - Authentication : 자신이 누구인지 확인하도록 사용자를 확인
            - Authorization : 사용자에게 특정 리소스에 대한 액세스 권한이 있는지 확인
            - Authentication에서 JWT 토큰으로 사용자의 정보를 파악하고 해당 사용자가 해당 리소스에 접근할 권한이 있는지를 판단하니까 Authentication + Authorization 둘 다 하는 거 아닌가? 그런데 왜 “Authorization 헤더”라고 이름을 지었는지 의문이 생겼다.
        - GPT 선생님의 의견에 따르면 정보도 포함되어 있지만, 최종적으로는 **권한 부여(Authorization)**의 역할을 수행하기 때문에 그렇게 명명된 것이라고 한다.

### 피드 읽기 API

- 뉴스 피드를 가져오는 API
- GET `/v1/me/feed`
    - Authorization header: API 호출 인증 값

## 시스템 구조

### 피드 발행 시스템

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/46cd9b42-2f38-4f3d-93aa-70891bf26d2a/Untitled.png)

- 사용자
    - 모바일 앱이나 브라우저에서 새 포스팅을 올리는 주체
    - 피드 발생 API를 사용하여 새 포스팅을 올린다.
    - POST `/v1/me/feed`
- 로드밸런서
    - 트래픽을 웹 서버들로 분산한다.
- 웹서버
    - HTTP 요청을 내부 서비스로 중계하는 역할을 한다.
- 웹 서버에서 동작하는 서비스 중 하나
    - 포스팅 저장 서비스
        - 새 포스팅을 데이터베이스와 캐시에 저장한다.
    - 포스팅 전송 서비스
        - 새 포스팅을 친구의 뉴스 피드에 푸시한다.
        - **캐시에 보관**하여 빠르게 읽을 수 있도록 한다.
            - **피드 캐시는 포스팅 데이터베이스에서 데이터를 가져오는 것이 일반적입니다**. 데이터베이스에서 최신 포스팅 데이터를 읽어와 피드 캐시에 저장하여 빠른 응답을 제공할 수 있다.
    - 알림 서비스
        - 친구들에게 새 포스팅이 올라왔음을 알리거나 푸시 알림을 보내는 역할을 한다.
    

### 뉴스 피드 생성 설계

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/f8503a24-77f5-43cc-8dd8-8d691dd4ed19/Untitled.png)

- 사용자
    - 피드 읽기 API를 호출한다.
    - GET `/v1/me/feed`
- 로드밸런서
    - 트래픽을 웹 서버들로 분산한다.
- 웹서버
    - 트래픽을 뉴스 피드 서비스로 보낸다.
- 뉴스 피드 서비스
    - 캐시에서 뉴스 피드를 가져온다.
- 뉴스 피드 캐시
    - 뉴스 피드를 렌더링할 때 필요한 피드 ID를 보관한다.

# 3단계 : 상세 설계

- 2단계에서는 컴포넌트 중심으로 설명했다면, 상세하게 설명하기 위해 웹서버와 포스팅 전송 서비스를 중점적으로 다뤄본다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/738264de-d977-4a45-98ed-02bc79d53536/Untitled.png)

### 웹서버

- 클라이언트와의 통신 + 인증이나 처리율 제한 등
    - ex) 인증 → Authorization 헤더에 토큰을 넣어 호출한 사용자만 포스팅 가능하다.
    - ex) 처리율 제한 → 한 사용자가 올릴 수 있는 포스팅 수에 제한을 두어야 한다. (스팸을 막고 유해한 콘텐츠가 자주 올라오는 것을 방지하기 위해 )

## 포스팅 전송(팬아웃) 서비스

- 포스팅 전송 == 팬아웃(fanout)
    - 어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정
- **팬아웃의 2가지 모델**
    - **1) 쓰기 시점에 팬아웃 ( = push 모델)**
        - 새로운 포스팅을 기록하자마자 바로 뉴스 피드 갱신!
        - 포스팅이 완료되면 바로 해당 사용자의 **캐시에** 해당 포스팅을 기록
        - 장점
            - 1) 뉴스 피드가 실시간으로 갱신되며 친구 목록에 있는 사용자에게 즉시 전송된다.
            - 2) 새 포스팅이 기록되는 순간에 뉴스 피드가 이미 갱신되므로(pre-computed) **뉴스 피드를 읽는 데 드는 시간이 짧아진다.**
        - 단점
            - 1) 핫키 문제
                - 친구 목록을 다 가져오고 그 목록에 있는 사용자들의 피드를 다 갱신해야하므로 친구가 많은 경우 많은 시간이 소요된다.
                    - ex) 제니의 피드를 올린 순간 몇천만 팔로워들의 뉴스피드를 다 갱신하려면 ..ㄷㄷ
            - 2) 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야하므로 컴퓨팅 자원이 낭비된다.
                - ex) 비밀번호를 까먹어서 n년째 방치중이고 다시 들어갈 수 없는 계정까지 업데이트 할 필요가 없음
            
    - **2) 읽기 시점에 팬아웃하는 모델 ( = pull 모델)**
        - 피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다.
        - 요청 기반(on-demand)의 모델임
        - 사용자가 타임라인을 로딩하는 시점에 새로운 포스트를 가져오게 된다.
        - 장점
            - 1) 비활성화된 사용자 또는 서비스를 자주 이용하지 않는 사용자에게 피드가 갱신되지 않으므로 컴퓨팅 자원을 아낄 수 있다.
            - 2) 데이터를 친구 목록에 있는 모든 사용자들에게 푸시하는 작업이 필요 없으므로 핫키 문제도 발생하지 않는다.
        - 단점
            - 1) 뉴스 피드를 읽는 데 많은 시간이 소요
        

### 두 가지 모델을 결합하자!

- 1) 뉴스 피드를 가져오는 작업에는 대부분의 사용자에게 **Push 모델**을 적용하고
    - 핫키가 발생할 수 있는 유명인의 경우 **Pull 모델**을 적용해 시스템 부하를 방지한다.
    - 두 모델을 나누는 기준?
        - **모니터링 및 분석**: 사용자 패턴을 분석하여 특정 기준에 따라 모델을 선택.
        - **동적 전환**: 사용자의 활동 변화에 따라 Push와 Pull 모델을 동적으로 전환.
- 2) 안정 해시를 통해 요청과 데이터를 보다 고르게 분산시켜 핫키 이슈를 자체를 줄이는 방법

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/2fbbeceb-fc58-4823-b286-2cab6d61dae8/Untitled.png)

1. **그래프 데이터베이스**에서 친구 ID목록을 가져온다.

- 소셜 네트워크는 자연스럽게 그래프로 표현되는 복잡한 관계(예: 공통 친구, 팔로어)를 가지고 있습니다.
- 그래프 데이터베이스는 수평 확장이 가능하여 수백만 명의 사용자가 생성한 방대한 양의 데이터를 수용할 수 있습니다.

2. **사용자 정보 캐시**에서 친구들의 정보를 가져온다 

→ 사용자 설정에 따라 업데이트 유무를 결정한다.

ex) 어떤 친구가 마음에 안들어서 뮤트했다면 그 친구의 새 스토리는 나의 피드에 보이지 않아야한다. 

3. 친구 목록과 새 스토리의 포스팅 ID를 메시지 큐에 넣는다.

4. 팬아웃 작업 서버가 메시지 큐에서 데이터를 꺼내어 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다.

- 뉴스 피드 캐시 테이블  → <포스팅 ID, 친구 ID> 순서쌍
    
    
    | post_id | user_id |
    | --- | --- |
    | post_id | user_id |
    | post_id | user_id |
    - 이때, 사용자 정보, 포스팅 정보까지 전부 캐시에 넣는 것은 메모리 요구량이 지나치게 많아질 수 있기 때문에 ID 정보만 캐시에 저장한다.
- 캐시 크기 제한 필요
    - 메모리 크기를 적정 수준으로 유지하기 위해 크기에 제한을 둔다.
    - 보통 사용자는 최신 스토리만 보려고 하므로 크기의 제한을 두어 오래된 스토리는 캐싱해두지 않아도 캐시 미스가 일어날 확률은 낮다.
    - 사용자가 자신이 보지 않은 천개의 스토리를 다 볼 확률은 적다.
    

## 피드 읽기 흐름 상세 설계

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/e2f63850-b15a-4799-a816-5fb93388a9f5/Untitled.png)

- 1) 사용자
    - 피드 읽기 API를 호출한다.
    - GET `/v1/me/feed`
- 2) 로드밸런서
    - 트래픽을 웹 서버들 가운데 하나로 보낸다.
- 3) 웹서버
    - 트래픽을 뉴스 피드 서비스를 호출
- 4) 뉴스 피드 서비스
    - 뉴스 피드 캐시에서 포스팅 ID 목록을 가져온다.
    - 5) 사용자 정보 캐시와 포스팅 캐시에서 뉴스 피드에 표시할 사용자 이름, 사진, 콘텐츠 등을 캐시에서 가져온다.
- 6) 생성된 뉴스피드를 JSON 형태로 클라이언트에게 보내고, 클라이언트는 해당 피드를 렌더링한다.

### 캐시 구조

- 뉴스 피드 시스템의 핵심 컴포넌트이다 (김밥의 단무지다)
- 아래와 같이 5개의 계층으로 나눈다.
    - 각각의 계층은 별도의 캐시 서버를 의미

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e2c6ccd4-4439-43db-96e9-e654aaf4aa71/861af110-8f0b-4a77-ab72-4f76b5ec5b8f/Untitled.png)

- 뉴스 피드
    - 뉴스피드의 ID를 보관한다.
- 콘텐츠
    - 포스팅 데이터를 보관하고 인기 콘텐츠는 따로 보관한다.
- 소셜 그래프
    - 사용자 간 관계 정보를 보관한다. (팔로워, 팔로잉)
- 행동
    - ‘좋아요’나 댓글 같은 사용자 행위에 관한 정보를 보관한다.
- 횟수
    - ‘좋아요’ 횟수, 응답 수, 팔로워 수, 팔로잉 수 등의 정보를 보관한다.

# 4단계 : 마무리

- 더 말하면 좋을 주제
    - 데이터베이스 규모 확장
    - 웹 계층을 무상태로 운영하기
    - 가능한 한 많은 데이터를 캐시할 방법
    - 여러 데이터 센터를 지원할 방법
    - 메시지 큐를 사용하여 컴포넌트 사이의 결합도 낮추기
    - 핵심 메트릭에 대한 모니터링.
        - 트래픽이 몰리는 시간대의 QPS, 사용자 피드를 새로고침할 때의 지연시간
